<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HF Interface Wrapper: EspPwm Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HF Interface Wrapper<span id="projectnumber">&#160;0.1.0-preview</span>
   </div>
   <div id="projectbrief">Embedded C++ hardware abstraction layer</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classEspPwm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classEspPwm-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">EspPwm Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>ESP32 PWM implementation using LEDC peripheral with comprehensive ESP32 variant support.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="EspPwm_8h_source.html">EspPwm.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for EspPwm:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classEspPwm__inherit__graph.svg" width="115" height="120"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for EspPwm:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classEspPwm__coll__graph.svg" width="100%" height="554"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEspPwm_1_1ChannelState.html">ChannelState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal channel state with per-channel callback support.  <a href="structEspPwm_1_1ChannelState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEspPwm_1_1ComplementaryPair.html">ComplementaryPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complementary output pair configuration.  <a href="structEspPwm_1_1ComplementaryPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEspPwm_1_1TimerState.html">TimerState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal timer state.  <a href="structEspPwm_1_1TimerState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEspPwm_1_1ValidationContext.html">ValidationContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple validation context for frequency/resolution validation.  <a href="structEspPwm_1_1ValidationContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEspPwm_1_1ValidationResult.html">ValidationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comprehensive validation result with detailed information.  <a href="structEspPwm_1_1ValidationResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae8e7d6e7f4ca605d4d4a361dc7806fd0" id="r_ae8e7d6e7f4ca605d4d4a361dc7806fd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8e7d6e7f4ca605d4d4a361dc7806fd0">EspPwm</a> (const <a class="el" href="structhf__pwm__unit__config__t.html">hf_pwm_unit_config_t</a> &amp;config=<a class="el" href="structhf__pwm__unit__config__t.html">hf_pwm_unit_config_t</a>{}) noexcept</td></tr>
<tr class="memdesc:ae8e7d6e7f4ca605d4d4a361dc7806fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for ESP32C6 PWM controller.  <br /></td></tr>
<tr class="separator:ae8e7d6e7f4ca605d4d4a361dc7806fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac5ce3f95ae8c5fb96312ad9a779ce6" id="r_aaac5ce3f95ae8c5fb96312ad9a779ce6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaac5ce3f95ae8c5fb96312ad9a779ce6">~EspPwm</a> () noexcept override</td></tr>
<tr class="memdesc:aaac5ce3f95ae8c5fb96312ad9a779ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor - ensures clean shutdown.  <br /></td></tr>
<tr class="separator:aaac5ce3f95ae8c5fb96312ad9a779ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda6756a1158a4cb37194c0690ac412f" id="r_adda6756a1158a4cb37194c0690ac412f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adda6756a1158a4cb37194c0690ac412f">EspPwm</a> (const <a class="el" href="classEspPwm.html">EspPwm</a> &amp;)=delete</td></tr>
<tr class="separator:adda6756a1158a4cb37194c0690ac412f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46e009618632e0db573912f71c94f9c" id="r_ae46e009618632e0db573912f71c94f9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEspPwm.html">EspPwm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae46e009618632e0db573912f71c94f9c">operator=</a> (const <a class="el" href="classEspPwm.html">EspPwm</a> &amp;)=delete</td></tr>
<tr class="separator:ae46e009618632e0db573912f71c94f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0523ebf8e643c95ad9b3ced6ff077fc7" id="r_a0523ebf8e643c95ad9b3ced6ff077fc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0523ebf8e643c95ad9b3ced6ff077fc7">EspPwm</a> (<a class="el" href="classEspPwm.html">EspPwm</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a0523ebf8e643c95ad9b3ced6ff077fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecba3137a0ead8abc259ab199648148b" id="r_aecba3137a0ead8abc259ab199648148b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEspPwm.html">EspPwm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecba3137a0ead8abc259ab199648148b">operator=</a> (<a class="el" href="classEspPwm.html">EspPwm</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:aecba3137a0ead8abc259ab199648148b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb8649c68e856258d6278bf399aab05" id="r_aedb8649c68e856258d6278bf399aab05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedb8649c68e856258d6278bf399aab05">Initialize</a> () noexcept override</td></tr>
<tr class="memdesc:aedb8649c68e856258d6278bf399aab05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the LEDC peripheral and PWM subsystem.  <br /></td></tr>
<tr class="separator:aedb8649c68e856258d6278bf399aab05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c857a39efec61ad79770770fca878c" id="r_a28c857a39efec61ad79770770fca878c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28c857a39efec61ad79770770fca878c">Deinitialize</a> () noexcept override</td></tr>
<tr class="memdesc:a28c857a39efec61ad79770770fca878c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize the LEDC peripheral and release all resources.  <br /></td></tr>
<tr class="separator:a28c857a39efec61ad79770770fca878c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848d38996b427bf51215bf0c0147a328" id="r_a848d38996b427bf51215bf0c0147a328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a848d38996b427bf51215bf0c0147a328">SetMode</a> (<a class="el" href="EspTypes__PWM_8h.html#aa74b1b34478ef0fde22cd029366ab3fa">hf_pwm_mode_t</a> mode) noexcept</td></tr>
<tr class="memdesc:a848d38996b427bf51215bf0c0147a328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM operating mode.  <br /></td></tr>
<tr class="separator:a848d38996b427bf51215bf0c0147a328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620e13937a4213f8c44219272302a1a7" id="r_a620e13937a4213f8c44219272302a1a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="EspTypes__PWM_8h.html#aa74b1b34478ef0fde22cd029366ab3fa">hf_pwm_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a620e13937a4213f8c44219272302a1a7">GetMode</a> () const noexcept</td></tr>
<tr class="memdesc:a620e13937a4213f8c44219272302a1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current PWM operating mode.  <br /></td></tr>
<tr class="separator:a620e13937a4213f8c44219272302a1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc265e040617403e718d4d28ff66e56" id="r_a4dc265e040617403e718d4d28ff66e56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dc265e040617403e718d4d28ff66e56">ConfigureChannel</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, const <a class="el" href="structhf__pwm__channel__config__t.html">hf_pwm_channel_config_t</a> &amp;config) noexcept</td></tr>
<tr class="memdesc:a4dc265e040617403e718d4d28ff66e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a PWM channel with comprehensive LEDC feature support.  <br /></td></tr>
<tr class="separator:a4dc265e040617403e718d4d28ff66e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416e064052b50ac0175651a5e191adc4" id="r_a416e064052b50ac0175651a5e191adc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a416e064052b50ac0175651a5e191adc4">DeconfigureChannel</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) noexcept</td></tr>
<tr class="memdesc:a416e064052b50ac0175651a5e191adc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deconfigure a channel and release all associated resources.  <br /></td></tr>
<tr class="separator:a416e064052b50ac0175651a5e191adc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd515c8685db84d5ff92a475063d663" id="r_a3bd515c8685db84d5ff92a475063d663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bd515c8685db84d5ff92a475063d663">EnableChannel</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) noexcept override</td></tr>
<tr class="memdesc:a3bd515c8685db84d5ff92a475063d663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable a configured PWM channel to start signal generation.  <br /></td></tr>
<tr class="separator:a3bd515c8685db84d5ff92a475063d663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff1addad40e1a81afa83a975b136e89" id="r_a8ff1addad40e1a81afa83a975b136e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ff1addad40e1a81afa83a975b136e89">DisableChannel</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) noexcept override</td></tr>
<tr class="memdesc:a8ff1addad40e1a81afa83a975b136e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable a PWM channel and stop signal generation.  <br /></td></tr>
<tr class="separator:a8ff1addad40e1a81afa83a975b136e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c737787080435a486d47ad3c6803e9" id="r_a07c737787080435a486d47ad3c6803e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07c737787080435a486d47ad3c6803e9">IsChannelEnabled</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) const noexcept override</td></tr>
<tr class="memdesc:a07c737787080435a486d47ad3c6803e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a PWM channel is currently enabled.  <br /></td></tr>
<tr class="separator:a07c737787080435a486d47ad3c6803e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4170c3b4661c0d4b9646eb3d775c88c" id="r_ae4170c3b4661c0d4b9646eb3d775c88c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4170c3b4661c0d4b9646eb3d775c88c">SetDutyCycle</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, float duty_cycle) noexcept override</td></tr>
<tr class="memdesc:ae4170c3b4661c0d4b9646eb3d775c88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM duty cycle as a percentage (0.0 to 1.0)  <br /></td></tr>
<tr class="separator:ae4170c3b4661c0d4b9646eb3d775c88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc8906d106762d5c9b1bcfd68ff0636" id="r_a6bc8906d106762d5c9b1bcfd68ff0636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bc8906d106762d5c9b1bcfd68ff0636">SetDutyCycleRaw</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> raw_value) noexcept override</td></tr>
<tr class="memdesc:a6bc8906d106762d5c9b1bcfd68ff0636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM duty cycle using raw timer counts.  <br /></td></tr>
<tr class="separator:a6bc8906d106762d5c9b1bcfd68ff0636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185108e6adbaaa23bcef4fbd8bda1b91" id="r_a185108e6adbaaa23bcef4fbd8bda1b91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a185108e6adbaaa23bcef4fbd8bda1b91">SetFrequency</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, <a class="el" href="HardwareTypes_8h.html#ae68c5caacf4873c3a0df851e11657bbc">hf_frequency_hz_t</a> frequency_hz) noexcept override</td></tr>
<tr class="memdesc:a185108e6adbaaa23bcef4fbd8bda1b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM frequency with automatic timer management.  <br /></td></tr>
<tr class="separator:a185108e6adbaaa23bcef4fbd8bda1b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6096fdc1d06345204c8062d2f86bd0c5" id="r_a6096fdc1d06345204c8062d2f86bd0c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6096fdc1d06345204c8062d2f86bd0c5">SetPhaseShift</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, float phase_shift_degrees) noexcept override</td></tr>
<tr class="memdesc:a6096fdc1d06345204c8062d2f86bd0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM phase shift (ESP32 LEDC limitation: not supported)  <br /></td></tr>
<tr class="separator:a6096fdc1d06345204c8062d2f86bd0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e2001e94083e72e12e0bf1a6f34d77" id="r_aa1e2001e94083e72e12e0bf1a6f34d77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1e2001e94083e72e12e0bf1a6f34d77">SetFrequencyWithResolution</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, <a class="el" href="HardwareTypes_8h.html#ae68c5caacf4873c3a0df851e11657bbc">hf_frequency_hz_t</a> frequency_hz, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits) noexcept</td></tr>
<tr class="memdesc:aa1e2001e94083e72e12e0bf1a6f34d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set frequency with explicit resolution choice (user-controlled)  <br /></td></tr>
<tr class="separator:aa1e2001e94083e72e12e0bf1a6f34d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe00eaeddf0a329994bdebf61d3439f9" id="r_abe00eaeddf0a329994bdebf61d3439f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe00eaeddf0a329994bdebf61d3439f9">SetFrequencyWithAutoFallback</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, <a class="el" href="HardwareTypes_8h.html#ae68c5caacf4873c3a0df851e11657bbc">hf_frequency_hz_t</a> frequency_hz, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> preferred_resolution) noexcept</td></tr>
<tr class="memdesc:abe00eaeddf0a329994bdebf61d3439f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set frequency with automatic fallback to alternative resolutions.  <br /></td></tr>
<tr class="separator:abe00eaeddf0a329994bdebf61d3439f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2795158cb647453ec43de6f9848417b" id="r_ae2795158cb647453ec43de6f9848417b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2795158cb647453ec43de6f9848417b">SetResolution</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits) noexcept</td></tr>
<tr class="memdesc:ae2795158cb647453ec43de6f9848417b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM resolution for a channel.  <br /></td></tr>
<tr class="separator:ae2795158cb647453ec43de6f9848417b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038775414699ae7a63277c2050ff7545" id="r_a038775414699ae7a63277c2050ff7545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a038775414699ae7a63277c2050ff7545">GetResolution</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) const noexcept</td></tr>
<tr class="memdesc:a038775414699ae7a63277c2050ff7545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current PWM resolution for a channel.  <br /></td></tr>
<tr class="separator:a038775414699ae7a63277c2050ff7545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98797ac6975b2f6ec3c297113bbf99d" id="r_aa98797ac6975b2f6ec3c297113bbf99d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa98797ac6975b2f6ec3c297113bbf99d">SetFrequencyAndResolution</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, <a class="el" href="HardwareTypes_8h.html#ae68c5caacf4873c3a0df851e11657bbc">hf_frequency_hz_t</a> frequency_hz, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits) noexcept</td></tr>
<tr class="memdesc:aa98797ac6975b2f6ec3c297113bbf99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set frequency and resolution together (atomic operation)  <br /></td></tr>
<tr class="separator:aa98797ac6975b2f6ec3c297113bbf99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cb19b3d0030bf788c976f05c4bd6e9" id="r_a23cb19b3d0030bf788c976f05c4bd6e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23cb19b3d0030bf788c976f05c4bd6e9">EnableAutoFallback</a> () noexcept</td></tr>
<tr class="memdesc:a23cb19b3d0030bf788c976f05c4bd6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable automatic fallback to alternative resolutions.  <br /></td></tr>
<tr class="separator:a23cb19b3d0030bf788c976f05c4bd6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda4cc0ceb6d711d81989a66d2fe3596" id="r_aeda4cc0ceb6d711d81989a66d2fe3596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeda4cc0ceb6d711d81989a66d2fe3596">DisableAutoFallback</a> () noexcept</td></tr>
<tr class="memdesc:aeda4cc0ceb6d711d81989a66d2fe3596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable automatic fallback to alternative resolutions.  <br /></td></tr>
<tr class="separator:aeda4cc0ceb6d711d81989a66d2fe3596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0842868ea3508b65542b2b3c46b155" id="r_adb0842868ea3508b65542b2b3c46b155"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb0842868ea3508b65542b2b3c46b155">IsAutoFallbackEnabled</a> () const noexcept</td></tr>
<tr class="memdesc:adb0842868ea3508b65542b2b3c46b155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if auto-fallback mode is enabled.  <br /></td></tr>
<tr class="separator:adb0842868ea3508b65542b2b3c46b155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130153d9f4bdaee4219736cb248d78f6" id="r_a130153d9f4bdaee4219736cb248d78f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a130153d9f4bdaee4219736cb248d78f6">StartAll</a> () noexcept override</td></tr>
<tr class="memdesc:a130153d9f4bdaee4219736cb248d78f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start all configured PWM channels simultaneously.  <br /></td></tr>
<tr class="separator:a130153d9f4bdaee4219736cb248d78f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be25ecab27ff61499a66535f303df2e" id="r_a8be25ecab27ff61499a66535f303df2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8be25ecab27ff61499a66535f303df2e">StopAll</a> () noexcept override</td></tr>
<tr class="memdesc:a8be25ecab27ff61499a66535f303df2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop all enabled PWM channels simultaneously.  <br /></td></tr>
<tr class="separator:a8be25ecab27ff61499a66535f303df2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5681d5ceb230b6dc0a459f3ef9630b8b" id="r_a5681d5ceb230b6dc0a459f3ef9630b8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5681d5ceb230b6dc0a459f3ef9630b8b">UpdateAll</a> () noexcept override</td></tr>
<tr class="memdesc:a5681d5ceb230b6dc0a459f3ef9630b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update all enabled PWM channels with their current settings.  <br /></td></tr>
<tr class="separator:a5681d5ceb230b6dc0a459f3ef9630b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4cc0b3c19e7258a063b1900f9d291a" id="r_a6c4cc0b3c19e7258a063b1900f9d291a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c4cc0b3c19e7258a063b1900f9d291a">SetComplementaryOutput</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> primary_channel, <a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> complementary_channel, <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> deadtime_ns) noexcept override</td></tr>
<tr class="memdesc:a6c4cc0b3c19e7258a063b1900f9d291a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure complementary PWM output pair with deadtime.  <br /></td></tr>
<tr class="separator:a6c4cc0b3c19e7258a063b1900f9d291a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3eda73cca25d298a3c7e3cbf133f03" id="r_aeb3eda73cca25d298a3c7e3cbf133f03"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb3eda73cca25d298a3c7e3cbf133f03">GetDutyCycle</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) const noexcept override</td></tr>
<tr class="memdesc:aeb3eda73cca25d298a3c7e3cbf133f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current duty cycle as a percentage.  <br /></td></tr>
<tr class="separator:aeb3eda73cca25d298a3c7e3cbf133f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4687559ad8744ece1ef578796b21eb02" id="r_a4687559ad8744ece1ef578796b21eb02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#ae68c5caacf4873c3a0df851e11657bbc">hf_frequency_hz_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4687559ad8744ece1ef578796b21eb02">GetFrequency</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) const noexcept override</td></tr>
<tr class="memdesc:a4687559ad8744ece1ef578796b21eb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current PWM frequency in Hz.  <br /></td></tr>
<tr class="separator:a4687559ad8744ece1ef578796b21eb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf9c46011b383820a588a9f153dfc52" id="r_a7cf9c46011b383820a588a9f153dfc52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cf9c46011b383820a588a9f153dfc52">GetChannelStatus</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, <a class="el" href="structhf__pwm__channel__status__t.html">hf_pwm_channel_status_t</a> &amp;status) const noexcept</td></tr>
<tr class="memdesc:a7cf9c46011b383820a588a9f153dfc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get comprehensive channel status and configuration.  <br /></td></tr>
<tr class="separator:a7cf9c46011b383820a588a9f153dfc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92695b9e07458d6280489d1ce3d8bdd" id="r_af92695b9e07458d6280489d1ce3d8bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af92695b9e07458d6280489d1ce3d8bdd">GetCapabilities</a> (<a class="el" href="structhf__pwm__capabilities__t.html">hf_pwm_capabilities_t</a> &amp;capabilities) const noexcept</td></tr>
<tr class="memdesc:af92695b9e07458d6280489d1ce3d8bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ESP32 variant-specific PWM capabilities.  <br /></td></tr>
<tr class="separator:af92695b9e07458d6280489d1ce3d8bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5a6eaafc83ba4ac56718fcded72d81" id="r_a1e5a6eaafc83ba4ac56718fcded72d81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e5a6eaafc83ba4ac56718fcded72d81">GetLastError</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) const noexcept</td></tr>
<tr class="memdesc:a1e5a6eaafc83ba4ac56718fcded72d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last error code for a specific channel.  <br /></td></tr>
<tr class="separator:a1e5a6eaafc83ba4ac56718fcded72d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543f85cebac06d91b5ac4fe7d6f325d6" id="r_a543f85cebac06d91b5ac4fe7d6f325d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a543f85cebac06d91b5ac4fe7d6f325d6">SetChannelFadeCallback</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, std::function&lt; void(<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a>)&gt; callback) noexcept</td></tr>
<tr class="memdesc:a543f85cebac06d91b5ac4fe7d6f325d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set per-channel callback for PWM fade completion events.  <br /></td></tr>
<tr class="separator:a543f85cebac06d91b5ac4fe7d6f325d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb67c853d1d7d042a047fbc22ae67c5" id="r_a9fb67c853d1d7d042a047fbc22ae67c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fb67c853d1d7d042a047fbc22ae67c5">SetHardwareFade</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, float target_duty_cycle, <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> fade_time_ms) noexcept</td></tr>
<tr class="memdesc:a9fb67c853d1d7d042a047fbc22ae67c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set hardware fade for smooth duty cycle transitions.  <br /></td></tr>
<tr class="separator:a9fb67c853d1d7d042a047fbc22ae67c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d06a21a6eda6c081f660895d81bbb1" id="r_ab3d06a21a6eda6c081f660895d81bbb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3d06a21a6eda6c081f660895d81bbb1">StopHardwareFade</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) noexcept</td></tr>
<tr class="memdesc:ab3d06a21a6eda6c081f660895d81bbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop hardware fade for a channel.  <br /></td></tr>
<tr class="separator:ab3d06a21a6eda6c081f660895d81bbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7006101d1efdbfa70c2b65604ded7b85" id="r_a7006101d1efdbfa70c2b65604ded7b85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7006101d1efdbfa70c2b65604ded7b85">IsFadeActive</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) const noexcept</td></tr>
<tr class="memdesc:a7006101d1efdbfa70c2b65604ded7b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if hardware fade is active on a channel.  <br /></td></tr>
<tr class="separator:a7006101d1efdbfa70c2b65604ded7b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d72b937ecff8d06181a2a0e7c7cb314" id="r_a1d72b937ecff8d06181a2a0e7c7cb314"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d72b937ecff8d06181a2a0e7c7cb314">SetIdleLevel</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> idle_level) noexcept</td></tr>
<tr class="memdesc:a1d72b937ecff8d06181a2a0e7c7cb314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set idle output level for a channel.  <br /></td></tr>
<tr class="separator:a1d72b937ecff8d06181a2a0e7c7cb314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4437f86f7dfc052c9abd0cd633c10e71" id="r_a4437f86f7dfc052c9abd0cd633c10e71"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4437f86f7dfc052c9abd0cd633c10e71">GetTimerAssignment</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) const noexcept</td></tr>
<tr class="memdesc:a4437f86f7dfc052c9abd0cd633c10e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current timer assignment for a channel.  <br /></td></tr>
<tr class="separator:a4437f86f7dfc052c9abd0cd633c10e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38358269d437372bb72805e76fc151ed" id="r_a38358269d437372bb72805e76fc151ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38358269d437372bb72805e76fc151ed">ForceTimerAssignment</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> timer_id) noexcept</td></tr>
<tr class="memdesc:a38358269d437372bb72805e76fc151ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a specific timer for a channel (advanced usage)  <br /></td></tr>
<tr class="separator:a38358269d437372bb72805e76fc151ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57006756d21e8f6b6c6c65c919b991e0" id="r_a57006756d21e8f6b6c6c65c919b991e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57006756d21e8f6b6c6c65c919b991e0">SetEvictionPolicy</a> (<a class="el" href="EspTypes__PWM_8h.html#ac87a4c9f233c95c6036c956aa21fdf72">hf_pwm_eviction_policy_t</a> policy) noexcept</td></tr>
<tr class="memdesc:a57006756d21e8f6b6c6c65c919b991e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set timer eviction policy for resource management.  <br /></td></tr>
<tr class="separator:a57006756d21e8f6b6c6c65c919b991e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf8969af578c46e95a7b16552c3442a" id="r_a6bf8969af578c46e95a7b16552c3442a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="EspTypes__PWM_8h.html#ac87a4c9f233c95c6036c956aa21fdf72">hf_pwm_eviction_policy_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bf8969af578c46e95a7b16552c3442a">GetEvictionPolicy</a> () const noexcept</td></tr>
<tr class="memdesc:a6bf8969af578c46e95a7b16552c3442a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current eviction policy.  <br /></td></tr>
<tr class="separator:a6bf8969af578c46e95a7b16552c3442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f27ca6f4deb563c66b584604bee706" id="r_a90f27ca6f4deb563c66b584604bee706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90f27ca6f4deb563c66b584604bee706">SetEvictionCallback</a> (<a class="el" href="EspTypes__PWM_8h.html#aa88988c1a4ef6005d3f20421ecba42ed">hf_pwm_eviction_callback_t</a> callback, void *user_data=nullptr) noexcept</td></tr>
<tr class="memdesc:a90f27ca6f4deb563c66b584604bee706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set eviction consent callback for user-controlled eviction.  <br /></td></tr>
<tr class="separator:a90f27ca6f4deb563c66b584604bee706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77340b2ecd211629ea79e7d9f151e063" id="r_a77340b2ecd211629ea79e7d9f151e063"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77340b2ecd211629ea79e7d9f151e063">SetChannelPriority</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, <a class="el" href="EspTypes__PWM_8h.html#ad8fbde8152ecafefd714f3a7eb8344c1">hf_pwm_channel_priority_t</a> priority) noexcept</td></tr>
<tr class="memdesc:a77340b2ecd211629ea79e7d9f151e063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set channel priority for eviction decisions.  <br /></td></tr>
<tr class="separator:a77340b2ecd211629ea79e7d9f151e063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572bf6e4c5628fb5996353922417c4bc" id="r_a572bf6e4c5628fb5996353922417c4bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="EspTypes__PWM_8h.html#ad8fbde8152ecafefd714f3a7eb8344c1">hf_pwm_channel_priority_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a572bf6e4c5628fb5996353922417c4bc">GetChannelPriority</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) const noexcept</td></tr>
<tr class="memdesc:a572bf6e4c5628fb5996353922417c4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get channel priority.  <br /></td></tr>
<tr class="separator:a572bf6e4c5628fb5996353922417c4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b222f44fa892e931bda82929f123d54" id="r_a7b222f44fa892e931bda82929f123d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b222f44fa892e931bda82929f123d54">SetChannelCritical</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, bool is_critical) noexcept</td></tr>
<tr class="memdesc:a7b222f44fa892e931bda82929f123d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark channel as critical (never evict)  <br /></td></tr>
<tr class="separator:a7b222f44fa892e931bda82929f123d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c715fe2272e8c1dc93e47f44ab56ac" id="r_a85c715fe2272e8c1dc93e47f44ab56ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85c715fe2272e8c1dc93e47f44ab56ac">IsChannelCritical</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) const noexcept</td></tr>
<tr class="memdesc:a85c715fe2272e8c1dc93e47f44ab56ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if channel is marked as critical.  <br /></td></tr>
<tr class="separator:a85c715fe2272e8c1dc93e47f44ab56ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff4ddc5a06060a4b7194154a7d28617" id="r_a9ff4ddc5a06060a4b7194154a7d28617"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ff4ddc5a06060a4b7194154a7d28617">GetStatistics</a> (<a class="el" href="structhf__pwm__statistics__t.html">hf_pwm_statistics_t</a> &amp;statistics) const noexcept override</td></tr>
<tr class="memdesc:a9ff4ddc5a06060a4b7194154a7d28617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get PWM statistics.  <br /></td></tr>
<tr class="separator:a9ff4ddc5a06060a4b7194154a7d28617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bc4616d9447ad43ec6d6c732049b59" id="r_a81bc4616d9447ad43ec6d6c732049b59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81bc4616d9447ad43ec6d6c732049b59">GetDiagnostics</a> (<a class="el" href="structhf__pwm__diagnostics__t.html">hf_pwm_diagnostics_t</a> &amp;diagnostics) const noexcept override</td></tr>
<tr class="memdesc:a81bc4616d9447ad43ec6d6c732049b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get PWM diagnostics.  <br /></td></tr>
<tr class="separator:a81bc4616d9447ad43ec6d6c732049b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classBasePwm"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classBasePwm')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classBasePwm.html">BasePwm</a></td></tr>
<tr class="memitem:a7481b15d121d631a59d1605780085d0e inherit pub_methods_classBasePwm" id="r_a7481b15d121d631a59d1605780085d0e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#a7481b15d121d631a59d1605780085d0e">~BasePwm</a> () noexcept=default</td></tr>
<tr class="separator:a7481b15d121d631a59d1605780085d0e inherit pub_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75191deb5eec96c9d1f99c7c981467d inherit pub_methods_classBasePwm" id="r_ab75191deb5eec96c9d1f99c7c981467d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#ab75191deb5eec96c9d1f99c7c981467d">IsInitialized</a> () const noexcept</td></tr>
<tr class="memdesc:ab75191deb5eec96c9d1f99c7c981467d inherit pub_methods_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if PWM system is initialized.  <br /></td></tr>
<tr class="separator:ab75191deb5eec96c9d1f99c7c981467d inherit pub_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa084e73274f2f1d1d67cff793eda1956 inherit pub_methods_classBasePwm" id="r_aa084e73274f2f1d1d67cff793eda1956"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#aa084e73274f2f1d1d67cff793eda1956">EnsureInitialized</a> () noexcept</td></tr>
<tr class="memdesc:aa084e73274f2f1d1d67cff793eda1956 inherit pub_methods_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure PWM is initialized (lazy initialization pattern)  <br /></td></tr>
<tr class="separator:aa084e73274f2f1d1d67cff793eda1956 inherit pub_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d407e46dff5f6c1f9ae2b7d68ea674c inherit pub_methods_classBasePwm" id="r_a8d407e46dff5f6c1f9ae2b7d68ea674c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#a8d407e46dff5f6c1f9ae2b7d68ea674c">EnsureDeinitialized</a> () noexcept</td></tr>
<tr class="memdesc:a8d407e46dff5f6c1f9ae2b7d68ea674c inherit pub_methods_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure PWM is deinitialized (lazy deinitialization pattern)  <br /></td></tr>
<tr class="separator:a8d407e46dff5f6c1f9ae2b7d68ea674c inherit pub_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7176a7fbb46fa45a5a2521060ef9c7 inherit pub_methods_classBasePwm" id="r_afb7176a7fbb46fa45a5a2521060ef9c7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#afb7176a7fbb46fa45a5a2521060ef9c7">ResetStatistics</a> () noexcept</td></tr>
<tr class="memdesc:afb7176a7fbb46fa45a5a2521060ef9c7 inherit pub_methods_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset PWM operation statistics.  <br /></td></tr>
<tr class="separator:afb7176a7fbb46fa45a5a2521060ef9c7 inherit pub_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef55c8bbd0a0fe57f2b21f286fc91dd inherit pub_methods_classBasePwm" id="r_abef55c8bbd0a0fe57f2b21f286fc91dd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#abef55c8bbd0a0fe57f2b21f286fc91dd">ResetDiagnostics</a> () noexcept</td></tr>
<tr class="memdesc:abef55c8bbd0a0fe57f2b21f286fc91dd inherit pub_methods_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset PWM diagnostic information.  <br /></td></tr>
<tr class="separator:abef55c8bbd0a0fe57f2b21f286fc91dd inherit pub_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1595caab94f2f77924d128115eab0be2" id="r_a1595caab94f2f77924d128115eab0be2"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1595caab94f2f77924d128115eab0be2">MAX_CHANNELS</a> = <a class="el" href="EspTypes__PWM_8h.html#a86d24d14ec124f4012f812f9853993f0">HF_PWM_MAX_CHANNELS</a></td></tr>
<tr class="memdesc:a1595caab94f2f77924d128115eab0be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum PWM channels.  <br /></td></tr>
<tr class="separator:a1595caab94f2f77924d128115eab0be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625133f35c2449a53e048f63df138a89" id="r_a625133f35c2449a53e048f63df138a89"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a625133f35c2449a53e048f63df138a89">MAX_TIMERS</a> = <a class="el" href="EspTypes__PWM_8h.html#a188b45a8dc354e4753a2d2a3ade6b06e">HF_PWM_MAX_TIMERS</a></td></tr>
<tr class="memdesc:a625133f35c2449a53e048f63df138a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum timer groups.  <br /></td></tr>
<tr class="separator:a625133f35c2449a53e048f63df138a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebf53a209f25236bafcb52fe0564d2a" id="r_a5ebf53a209f25236bafcb52fe0564d2a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ebf53a209f25236bafcb52fe0564d2a">MAX_RESOLUTION</a> = <a class="el" href="EspTypes__PWM_8h.html#ae635150b452b279b29b65f799961d51f">HF_PWM_MAX_RESOLUTION</a></td></tr>
<tr class="memdesc:a5ebf53a209f25236bafcb52fe0564d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum resolution bits.  <br /></td></tr>
<tr class="separator:a5ebf53a209f25236bafcb52fe0564d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03e7350d2c885bbca5358ee3a183d10" id="r_af03e7350d2c885bbca5358ee3a183d10"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af03e7350d2c885bbca5358ee3a183d10">MIN_FREQUENCY</a> = <a class="el" href="EspTypes__PWM_8h.html#ab59b928c49e8f4ef0dbc7c1bac390c93">HF_PWM_MIN_FREQUENCY</a></td></tr>
<tr class="memdesc:af03e7350d2c885bbca5358ee3a183d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum frequency (Hz)  <br /></td></tr>
<tr class="separator:af03e7350d2c885bbca5358ee3a183d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9028b609b50b17802ce3b8da3ec39899" id="r_a9028b609b50b17802ce3b8da3ec39899"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9028b609b50b17802ce3b8da3ec39899">MAX_FREQUENCY</a> = <a class="el" href="EspTypes__PWM_8h.html#aefdd9851ea138af7ce3b87a861c9f8b7">HF_PWM_MAX_FREQUENCY</a></td></tr>
<tr class="memdesc:a9028b609b50b17802ce3b8da3ec39899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum frequency (Hz)  <br /></td></tr>
<tr class="separator:a9028b609b50b17802ce3b8da3ec39899"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4fcc3a06cf3ba05f0f0524257d9ebf0d" id="r_a4fcc3a06cf3ba05f0f0524257d9ebf0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fcc3a06cf3ba05f0f0524257d9ebf0d">IsValidChannelId</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) const noexcept</td></tr>
<tr class="memdesc:a4fcc3a06cf3ba05f0f0524257d9ebf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate channel ID.  <br /></td></tr>
<tr class="separator:a4fcc3a06cf3ba05f0f0524257d9ebf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f782916b4f7d5dabe48e2c913ea98e9" id="r_a8f782916b4f7d5dabe48e2c913ea98e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#a88065d24fa2d174cf7b698ce5d498c44">hf_i8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f782916b4f7d5dabe48e2c913ea98e9">FindOrAllocateTimer</a> (<a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> frequency_hz, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits, <a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a> clock_source) noexcept</td></tr>
<tr class="memdesc:a8f782916b4f7d5dabe48e2c913ea98e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unified timer allocation with comprehensive strategy.  <br /></td></tr>
<tr class="separator:a8f782916b4f7d5dabe48e2c913ea98e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd0e9059cb48af8c52140ff2ac7cf8c" id="r_aecd0e9059cb48af8c52140ff2ac7cf8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecd0e9059cb48af8c52140ff2ac7cf8c">ReleaseTimerIfUnused</a> (<a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> timer_id) noexcept</td></tr>
<tr class="memdesc:aecd0e9059cb48af8c52140ff2ac7cf8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a timer if no longer needed with hardware cleanup.  <br /></td></tr>
<tr class="separator:aecd0e9059cb48af8c52140ff2ac7cf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362d7335d05a027efd2a9429bf4d8e40" id="r_a362d7335d05a027efd2a9429bf4d8e40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a362d7335d05a027efd2a9429bf4d8e40">ConfigurePlatformTimer</a> (<a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> timer_id, <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> frequency_hz, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits, <a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a> clock_source) noexcept</td></tr>
<tr class="memdesc:a362d7335d05a027efd2a9429bf4d8e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure platform timer with LEDC peripheral integration.  <br /></td></tr>
<tr class="separator:a362d7335d05a027efd2a9429bf4d8e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023bc718f864eb1e2b887c4de5013fa9" id="r_a023bc718f864eb1e2b887c4de5013fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a023bc718f864eb1e2b887c4de5013fa9">ConfigurePlatformChannel</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, const <a class="el" href="structhf__pwm__channel__config__t.html">hf_pwm_channel_config_t</a> &amp;config, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> timer_id) noexcept</td></tr>
<tr class="memdesc:a023bc718f864eb1e2b887c4de5013fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure platform channel.  <br /></td></tr>
<tr class="separator:a023bc718f864eb1e2b887c4de5013fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb62a6be326c25671cc8780618902cd4" id="r_aeb62a6be326c25671cc8780618902cd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb62a6be326c25671cc8780618902cd4">UpdatePlatformDuty</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> raw_duty_value) noexcept</td></tr>
<tr class="memdesc:aeb62a6be326c25671cc8780618902cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update platform duty cycle.  <br /></td></tr>
<tr class="separator:aeb62a6be326c25671cc8780618902cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4f2fafd78318e313ced753414f11d2" id="r_a6b4f2fafd78318e313ced753414f11d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b4f2fafd78318e313ced753414f11d2">SetChannelError</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, <a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> error) noexcept</td></tr>
<tr class="memdesc:a6b4f2fafd78318e313ced753414f11d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set error for a channel.  <br /></td></tr>
<tr class="separator:a6b4f2fafd78318e313ced753414f11d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c248eb7f9a03bf23e992c4f75b46fc" id="r_af0c248eb7f9a03bf23e992c4f75b46fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0c248eb7f9a03bf23e992c4f75b46fc">HandleFadeComplete</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) noexcept</td></tr>
<tr class="memdesc:af0c248eb7f9a03bf23e992c4f75b46fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle fade complete interrupt.  <br /></td></tr>
<tr class="separator:af0c248eb7f9a03bf23e992c4f75b46fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3189d43f89c413fbf2b047339b9d8eed" id="r_a3189d43f89c413fbf2b047339b9d8eed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3189d43f89c413fbf2b047339b9d8eed">RegisterLedcFadeCallback</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) noexcept</td></tr>
<tr class="memdesc:a3189d43f89c413fbf2b047339b9d8eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register LEDC fade callback using ESP-IDF API.  <br /></td></tr>
<tr class="separator:a3189d43f89c413fbf2b047339b9d8eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e0799a5758dd6159e417fcf00c5d31" id="r_a51e0799a5758dd6159e417fcf00c5d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51e0799a5758dd6159e417fcf00c5d31">UnregisterLedcFadeCallback</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id) noexcept</td></tr>
<tr class="memdesc:a51e0799a5758dd6159e417fcf00c5d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister LEDC fade callback.  <br /></td></tr>
<tr class="separator:a51e0799a5758dd6159e417fcf00c5d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd65e0509706ecefd541b8546596469" id="r_abfd65e0509706ecefd541b8546596469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfd65e0509706ecefd541b8546596469">InitializeFadeFunctionality</a> () noexcept</td></tr>
<tr class="memdesc:abfd65e0509706ecefd541b8546596469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize LEDC fade functionality.  <br /></td></tr>
<tr class="separator:abfd65e0509706ecefd541b8546596469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e920ee5ebeced7fbe9dd8a80622605" id="r_ae9e920ee5ebeced7fbe9dd8a80622605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9e920ee5ebeced7fbe9dd8a80622605">InitializeTimers</a> () noexcept</td></tr>
<tr class="memdesc:ae9e920ee5ebeced7fbe9dd8a80622605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize PWM timers.  <br /></td></tr>
<tr class="separator:ae9e920ee5ebeced7fbe9dd8a80622605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ee8dcae85c2b59b80dbc996522a7b2" id="r_ab8ee8dcae85c2b59b80dbc996522a7b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8ee8dcae85c2b59b80dbc996522a7b2">InitializeChannels</a> () noexcept</td></tr>
<tr class="memdesc:ab8ee8dcae85c2b59b80dbc996522a7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize PWM channels.  <br /></td></tr>
<tr class="separator:ab8ee8dcae85c2b59b80dbc996522a7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9192ec3aa26d9acac2c0e6ec30c6bed1" id="r_a9192ec3aa26d9acac2c0e6ec30c6bed1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9192ec3aa26d9acac2c0e6ec30c6bed1">EnableFade</a> () noexcept</td></tr>
<tr class="memdesc:a9192ec3aa26d9acac2c0e6ec30c6bed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable fade functionality.  <br /></td></tr>
<tr class="separator:a9192ec3aa26d9acac2c0e6ec30c6bed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a19207d3326cb8f660670a6fa46035c" id="r_a6a19207d3326cb8f660670a6fa46035c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a19207d3326cb8f660670a6fa46035c">CalculateClockDivider</a> (<a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> frequency_hz, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits) const noexcept</td></tr>
<tr class="memdesc:a6a19207d3326cb8f660670a6fa46035c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate optimal clock divider for frequency.  <br /></td></tr>
<tr class="separator:a6a19207d3326cb8f660670a6fa46035c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd81092951838b5058abd3db6ad7a0af" id="r_abd81092951838b5058abd3db6ad7a0af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEspPwm_1_1ValidationResult.html">ValidationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd81092951838b5058abd3db6ad7a0af">ValidateFrequencyResolutionComplete</a> (const <a class="el" href="structEspPwm_1_1ValidationContext.html">ValidationContext</a> &amp;context) const noexcept</td></tr>
<tr class="memdesc:abd81092951838b5058abd3db6ad7a0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unified comprehensive validation for frequency/resolution combinations.  <br /></td></tr>
<tr class="separator:abd81092951838b5058abd3db6ad7a0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9124b114f15aa018720cff258fe4bda" id="r_ab9124b114f15aa018720cff258fe4bda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9124b114f15aa018720cff258fe4bda">GetSourceClockFrequency</a> (<a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a> clock_source) const noexcept</td></tr>
<tr class="memdesc:ab9124b114f15aa018720cff258fe4bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get source clock frequency for a given clock source.  <br /></td></tr>
<tr class="separator:ab9124b114f15aa018720cff258fe4bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a2e6d7bd1a18b68089d5f3bdea2e34" id="r_af5a2e6d7bd1a18b68089d5f3bdea2e34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5a2e6d7bd1a18b68089d5f3bdea2e34">CalculateMaxResolution</a> (<a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> frequency_hz, <a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a> clock_source=<a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82a2fb4f97b7c1b78586a5f9f8365272822">hf_pwm_clock_source_t::HF_PWM_CLK_SRC_APB</a>) const noexcept</td></tr>
<tr class="memdesc:af5a2e6d7bd1a18b68089d5f3bdea2e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate maximum achievable resolution for a given frequency.  <br /></td></tr>
<tr class="separator:af5a2e6d7bd1a18b68089d5f3bdea2e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa0af5ac18437a6235fcbdfca39b222" id="r_a1fa0af5ac18437a6235fcbdfca39b222"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fa0af5ac18437a6235fcbdfca39b222">CalculateMaxFrequency</a> (<a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits, <a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a> clock_source=<a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82a2fb4f97b7c1b78586a5f9f8365272822">hf_pwm_clock_source_t::HF_PWM_CLK_SRC_APB</a>) const noexcept</td></tr>
<tr class="memdesc:a1fa0af5ac18437a6235fcbdfca39b222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate maximum achievable frequency for a given resolution.  <br /></td></tr>
<tr class="separator:a1fa0af5ac18437a6235fcbdfca39b222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3662ff3251aebe8026b16bef3773420" id="r_aa3662ff3251aebe8026b16bef3773420"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3662ff3251aebe8026b16bef3773420">ValidateDutyCycleRange</a> (<a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> raw_duty, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits) const noexcept</td></tr>
<tr class="memdesc:aa3662ff3251aebe8026b16bef3773420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enhanced duty cycle validation with overflow protection.  <br /></td></tr>
<tr class="separator:aa3662ff3251aebe8026b16bef3773420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5f74505d1c596936c02d9f2c465158" id="r_a0e5f74505d1c596936c02d9f2c465158"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e5f74505d1c596936c02d9f2c465158">IsClockSourceCompatible</a> (<a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a> timer_clock, <a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a> requested_clock) const noexcept</td></tr>
<tr class="memdesc:a0e5f74505d1c596936c02d9f2c465158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two clock sources are compatible for timer sharing.  <br /></td></tr>
<tr class="separator:a0e5f74505d1c596936c02d9f2c465158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad352f2f3a014631f98d996814c806163" id="r_ad352f2f3a014631f98d996814c806163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad352f2f3a014631f98d996814c806163">FindBestAlternativeResolutionDynamic</a> (<a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> frequency_hz, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> preferred_resolution, <a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a> clock_source=<a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82a2fb4f97b7c1b78586a5f9f8365272822">hf_pwm_clock_source_t::HF_PWM_CLK_SRC_APB</a>) const noexcept</td></tr>
<tr class="memdesc:ad352f2f3a014631f98d996814c806163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find best alternative resolution using dynamic calculation.  <br /></td></tr>
<tr class="separator:ad352f2f3a014631f98d996814c806163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da40e9d83cc49cbf26f5ac4e4c3f665" id="r_a6da40e9d83cc49cbf26f5ac4e4c3f665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6da40e9d83cc49cbf26f5ac4e4c3f665">NotifyTimerReconfiguration</a> (<a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> timer_id, <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> new_frequency, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits) noexcept</td></tr>
<tr class="memdesc:a6da40e9d83cc49cbf26f5ac4e4c3f665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify channels that their timer has been reconfigured.  <br /></td></tr>
<tr class="separator:a6da40e9d83cc49cbf26f5ac4e4c3f665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981f330beac42c81c414ccc57606a894" id="r_a981f330beac42c81c414ccc57606a894"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981f330beac42c81c414ccc57606a894">GetTimerUsageInfo</a> (<a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> timer_id) const noexcept</td></tr>
<tr class="memdesc:a981f330beac42c81c414ccc57606a894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get timer usage information for debugging.  <br /></td></tr>
<tr class="separator:a981f330beac42c81c414ccc57606a894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4836d32ff7c987bf03f403fa3f7ee660" id="r_a4836d32ff7c987bf03f403fa3f7ee660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4836d32ff7c987bf03f403fa3f7ee660">PerformTimerHealthCheck</a> () noexcept</td></tr>
<tr class="memdesc:a4836d32ff7c987bf03f403fa3f7ee660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform comprehensive timer health check and cleanup.  <br /></td></tr>
<tr class="separator:a4836d32ff7c987bf03f403fa3f7ee660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b455ad1230974f857a6cf89cc1598fb" id="r_a0b455ad1230974f857a6cf89cc1598fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#a88065d24fa2d174cf7b698ce5d498c44">hf_i8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b455ad1230974f857a6cf89cc1598fb">AttemptSafeEviction</a> (<a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> frequency_hz, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits) noexcept</td></tr>
<tr class="memdesc:a0b455ad1230974f857a6cf89cc1598fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt safe timer eviction based on user policy.  <br /></td></tr>
<tr class="separator:a0b455ad1230974f857a6cf89cc1598fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351d6b815860b91b7ed60d59cf00cb39" id="r_a351d6b815860b91b7ed60d59cf00cb39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#a88065d24fa2d174cf7b698ce5d498c44">hf_i8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a351d6b815860b91b7ed60d59cf00cb39">AttemptEvictionWithConsent</a> (<a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> frequency_hz, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits) noexcept</td></tr>
<tr class="memdesc:a351d6b815860b91b7ed60d59cf00cb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt eviction with user consent callback.  <br /></td></tr>
<tr class="separator:a351d6b815860b91b7ed60d59cf00cb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6278208d17f1ae7c3dcc2c94abdc6dbd" id="r_a6278208d17f1ae7c3dcc2c94abdc6dbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#a88065d24fa2d174cf7b698ce5d498c44">hf_i8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6278208d17f1ae7c3dcc2c94abdc6dbd">AttemptEvictionNonCritical</a> (<a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> frequency_hz, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits) noexcept</td></tr>
<tr class="memdesc:a6278208d17f1ae7c3dcc2c94abdc6dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt eviction of non-critical channels only.  <br /></td></tr>
<tr class="separator:a6278208d17f1ae7c3dcc2c94abdc6dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3e5e9d0cf58e8c9aa9e912a5e18bb2" id="r_a3a3e5e9d0cf58e8c9aa9e912a5e18bb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#a88065d24fa2d174cf7b698ce5d498c44">hf_i8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a3e5e9d0cf58e8c9aa9e912a5e18bb2">AttemptForceEviction</a> (<a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> frequency_hz, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits) noexcept</td></tr>
<tr class="memdesc:a3a3e5e9d0cf58e8c9aa9e912a5e18bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt aggressive eviction (original behavior)  <br /></td></tr>
<tr class="separator:a3a3e5e9d0cf58e8c9aa9e912a5e18bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a48b2831d8333eeedead0a65ca3d5af08" id="r_a48b2831d8333eeedead0a65ca3d5af08"><td class="memItemLeft" align="right" valign="top">static void IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48b2831d8333eeedead0a65ca3d5af08">InterruptHandler</a> (<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel_id, void *user_data) noexcept</td></tr>
<tr class="memdesc:a48b2831d8333eeedead0a65ca3d5af08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-specific interrupt handler.  <br /></td></tr>
<tr class="separator:a48b2831d8333eeedead0a65ca3d5af08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f60f5e67b3db043af66624f022e7b2" id="r_aa2f60f5e67b3db043af66624f022e7b2"><td class="memItemLeft" align="right" valign="top">static bool IRAM_ATTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2f60f5e67b3db043af66624f022e7b2">LedcFadeEndCallback</a> (const ledc_cb_param_t *param, void *user_arg) noexcept</td></tr>
<tr class="memdesc:aa2f60f5e67b3db043af66624f022e7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static ESP-IDF LEDC fade callback handler (C-compatible)  <br /></td></tr>
<tr class="separator:aa2f60f5e67b3db043af66624f022e7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae4c8b8e2abef78e240fc60451b6d793e" id="r_ae4c8b8e2abef78e240fc60451b6d793e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRtosMutex.html">RtosMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4c8b8e2abef78e240fc60451b6d793e">mutex_</a></td></tr>
<tr class="memdesc:ae4c8b8e2abef78e240fc60451b6d793e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread safety mutex.  <br /></td></tr>
<tr class="separator:ae4c8b8e2abef78e240fc60451b6d793e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f5455c00a2bf6bee32c4edeb5b90d0" id="r_a62f5455c00a2bf6bee32c4edeb5b90d0"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62f5455c00a2bf6bee32c4edeb5b90d0">initialized_</a></td></tr>
<tr class="memdesc:a62f5455c00a2bf6bee32c4edeb5b90d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization state (atomic for lazy init)  <br /></td></tr>
<tr class="separator:a62f5455c00a2bf6bee32c4edeb5b90d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2698a4d9441132c4f9ba23a4dc4678" id="r_adb2698a4d9441132c4f9ba23a4dc4678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb2698a4d9441132c4f9ba23a4dc4678">base_clock_hz_</a></td></tr>
<tr class="memdesc:adb2698a4d9441132c4f9ba23a4dc4678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base clock frequency.  <br /></td></tr>
<tr class="separator:adb2698a4d9441132c4f9ba23a4dc4678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4da347398a044e97ecfd586a65d4470" id="r_ac4da347398a044e97ecfd586a65d4470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4da347398a044e97ecfd586a65d4470">clock_source_</a></td></tr>
<tr class="memdesc:ac4da347398a044e97ecfd586a65d4470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current clock source.  <br /></td></tr>
<tr class="separator:ac4da347398a044e97ecfd586a65d4470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3341c72b5f1d413999dfc44fd8d80d2" id="r_ab3341c72b5f1d413999dfc44fd8d80d2"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structEspPwm_1_1ChannelState.html">ChannelState</a>, <a class="el" href="#a1595caab94f2f77924d128115eab0be2">MAX_CHANNELS</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3341c72b5f1d413999dfc44fd8d80d2">channels_</a></td></tr>
<tr class="memdesc:ab3341c72b5f1d413999dfc44fd8d80d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Channel states.  <br /></td></tr>
<tr class="separator:ab3341c72b5f1d413999dfc44fd8d80d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad569f2cfbea460323ab5847717019d75" id="r_ad569f2cfbea460323ab5847717019d75"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structEspPwm_1_1TimerState.html">TimerState</a>, <a class="el" href="#a625133f35c2449a53e048f63df138a89">MAX_TIMERS</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad569f2cfbea460323ab5847717019d75">timers_</a></td></tr>
<tr class="memdesc:ad569f2cfbea460323ab5847717019d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer states.  <br /></td></tr>
<tr class="separator:ad569f2cfbea460323ab5847717019d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfcaf9396528e32f648a403fd4fb075" id="r_afdfcaf9396528e32f648a403fd4fb075"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structEspPwm_1_1ComplementaryPair.html">ComplementaryPair</a>, <a class="el" href="#a1595caab94f2f77924d128115eab0be2">MAX_CHANNELS</a>/2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdfcaf9396528e32f648a403fd4fb075">complementary_pairs_</a></td></tr>
<tr class="memdesc:afdfcaf9396528e32f648a403fd4fb075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complementary pairs.  <br /></td></tr>
<tr class="separator:afdfcaf9396528e32f648a403fd4fb075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b06777e74eedca37e5023ec23fc4ce" id="r_ad1b06777e74eedca37e5023ec23fc4ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1b06777e74eedca37e5023ec23fc4ce">last_global_error_</a></td></tr>
<tr class="memdesc:ad1b06777e74eedca37e5023ec23fc4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last global error.  <br /></td></tr>
<tr class="separator:ad1b06777e74eedca37e5023ec23fc4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab200d2d51794d3c3f6c18945132bc7e4" id="r_ab200d2d51794d3c3f6c18945132bc7e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab200d2d51794d3c3f6c18945132bc7e4">fade_functionality_installed_</a></td></tr>
<tr class="memdesc:ab200d2d51794d3c3f6c18945132bc7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">LEDC fade functionality installed.  <br /></td></tr>
<tr class="separator:ab200d2d51794d3c3f6c18945132bc7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2592dd4dbe1e99213a7d1d4c69e67fd" id="r_ac2592dd4dbe1e99213a7d1d4c69e67fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhf__pwm__unit__config__t.html">hf_pwm_unit_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2592dd4dbe1e99213a7d1d4c69e67fd">unit_config_</a></td></tr>
<tr class="memdesc:ac2592dd4dbe1e99213a7d1d4c69e67fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit configuration.  <br /></td></tr>
<tr class="separator:ac2592dd4dbe1e99213a7d1d4c69e67fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364fe8d01eaea5c9664f43c8c2bd2dcb" id="r_a364fe8d01eaea5c9664f43c8c2bd2dcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="EspTypes__PWM_8h.html#aa74b1b34478ef0fde22cd029366ab3fa">hf_pwm_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a364fe8d01eaea5c9664f43c8c2bd2dcb">current_mode_</a></td></tr>
<tr class="memdesc:a364fe8d01eaea5c9664f43c8c2bd2dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current operating mode.  <br /></td></tr>
<tr class="separator:a364fe8d01eaea5c9664f43c8c2bd2dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe4a2dfe1bccd062a299b1febb8aef8" id="r_aefe4a2dfe1bccd062a299b1febb8aef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhf__pwm__statistics__t.html">hf_pwm_statistics_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefe4a2dfe1bccd062a299b1febb8aef8">statistics_</a></td></tr>
<tr class="memdesc:aefe4a2dfe1bccd062a299b1febb8aef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM statistics.  <br /></td></tr>
<tr class="separator:aefe4a2dfe1bccd062a299b1febb8aef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825cbef48b32048590def430ae108584" id="r_a825cbef48b32048590def430ae108584"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhf__pwm__diagnostics__t.html">hf_pwm_diagnostics_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a825cbef48b32048590def430ae108584">diagnostics_</a></td></tr>
<tr class="memdesc:a825cbef48b32048590def430ae108584"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM diagnostics.  <br /></td></tr>
<tr class="separator:a825cbef48b32048590def430ae108584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3b42702956b65454339f9a61458806" id="r_a1f3b42702956b65454339f9a61458806"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f3b42702956b65454339f9a61458806">auto_fallback_enabled_</a></td></tr>
<tr class="memdesc:a1f3b42702956b65454339f9a61458806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to automatically try alternative resolutions.  <br /></td></tr>
<tr class="separator:a1f3b42702956b65454339f9a61458806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1584998723762eec8692090592650f" id="r_a1f1584998723762eec8692090592650f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="EspTypes__PWM_8h.html#ac87a4c9f233c95c6036c956aa21fdf72">hf_pwm_eviction_policy_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f1584998723762eec8692090592650f">eviction_policy_</a></td></tr>
<tr class="memdesc:a1f1584998723762eec8692090592650f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer eviction policy (default: STRICT_NO_EVICTION)  <br /></td></tr>
<tr class="separator:a1f1584998723762eec8692090592650f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60137ac8d1bee195299fd6b2fa88431" id="r_ac60137ac8d1bee195299fd6b2fa88431"><td class="memItemLeft" align="right" valign="top"><a class="el" href="EspTypes__PWM_8h.html#aa88988c1a4ef6005d3f20421ecba42ed">hf_pwm_eviction_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac60137ac8d1bee195299fd6b2fa88431">eviction_callback_</a></td></tr>
<tr class="memdesc:ac60137ac8d1bee195299fd6b2fa88431"><td class="mdescLeft">&#160;</td><td class="mdescRight">User callback for eviction consent.  <br /></td></tr>
<tr class="separator:ac60137ac8d1bee195299fd6b2fa88431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae786082f476290ff5907881989d986" id="r_a2ae786082f476290ff5907881989d986"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ae786082f476290ff5907881989d986">eviction_callback_user_data_</a></td></tr>
<tr class="memdesc:a2ae786082f476290ff5907881989d986"><td class="mdescLeft">&#160;</td><td class="mdescRight">User data for eviction callback.  <br /></td></tr>
<tr class="separator:a2ae786082f476290ff5907881989d986"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classBasePwm"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classBasePwm')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classBasePwm.html">BasePwm</a></td></tr>
<tr class="memitem:a4cba17ff79ce18faaf8b402d2b212060 inherit pub_static_methods_classBasePwm" id="r_a4cba17ff79ce18faaf8b402d2b212060"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#a4cba17ff79ce18faaf8b402d2b212060">DutyCycleToRaw</a> (float duty_cycle, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits) noexcept</td></tr>
<tr class="memdesc:a4cba17ff79ce18faaf8b402d2b212060 inherit pub_static_methods_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate raw duty value from percentage.  <br /></td></tr>
<tr class="separator:a4cba17ff79ce18faaf8b402d2b212060 inherit pub_static_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6d82b9da888f91bd66e91b24121add inherit pub_static_methods_classBasePwm" id="r_a4a6d82b9da888f91bd66e91b24121add"><td class="memItemLeft" align="right" valign="top">static constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#a4a6d82b9da888f91bd66e91b24121add">RawToDutyCycle</a> (<a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> raw_value, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits) noexcept</td></tr>
<tr class="memdesc:a4a6d82b9da888f91bd66e91b24121add inherit pub_static_methods_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate duty cycle percentage from raw value.  <br /></td></tr>
<tr class="separator:a4a6d82b9da888f91bd66e91b24121add inherit pub_static_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352f6ddcf05ff0e0ed5c606098b24987 inherit pub_static_methods_classBasePwm" id="r_a352f6ddcf05ff0e0ed5c606098b24987"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#a352f6ddcf05ff0e0ed5c606098b24987">IsValidDutyCycle</a> (float duty_cycle) noexcept</td></tr>
<tr class="memdesc:a352f6ddcf05ff0e0ed5c606098b24987 inherit pub_static_methods_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate duty cycle range.  <br /></td></tr>
<tr class="separator:a352f6ddcf05ff0e0ed5c606098b24987 inherit pub_static_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab866dbce084437c35b3189f4e2952e inherit pub_static_methods_classBasePwm" id="r_afab866dbce084437c35b3189f4e2952e"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#afab866dbce084437c35b3189f4e2952e">IsValidFrequency</a> (<a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> frequency_hz, <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> min_freq_hz, <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> max_freq_hz) noexcept</td></tr>
<tr class="memdesc:afab866dbce084437c35b3189f4e2952e inherit pub_static_methods_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate frequency range.  <br /></td></tr>
<tr class="separator:afab866dbce084437c35b3189f4e2952e inherit pub_static_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aae2c9b79963e8648c9cf9e6e22bc11 inherit pub_static_methods_classBasePwm" id="r_a4aae2c9b79963e8648c9cf9e6e22bc11"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#a4aae2c9b79963e8648c9cf9e6e22bc11">IsValidRawDuty</a> (<a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> raw_value, <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> resolution_bits) noexcept</td></tr>
<tr class="memdesc:a4aae2c9b79963e8648c9cf9e6e22bc11 inherit pub_static_methods_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate raw duty value against resolution.  <br /></td></tr>
<tr class="separator:a4aae2c9b79963e8648c9cf9e6e22bc11 inherit pub_static_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbbc012f5c178e574e2fbb3bee3baf3 inherit pub_static_methods_classBasePwm" id="r_a1cbbc012f5c178e574e2fbb3bee3baf3"><td class="memItemLeft" align="right" valign="top">static constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#a1cbbc012f5c178e574e2fbb3bee3baf3">CalculateFrequencyAccuracy</a> (<a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> target_freq, <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> actual_freq) noexcept</td></tr>
<tr class="memdesc:a1cbbc012f5c178e574e2fbb3bee3baf3 inherit pub_static_methods_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate frequency accuracy percentage.  <br /></td></tr>
<tr class="separator:a1cbbc012f5c178e574e2fbb3bee3baf3 inherit pub_static_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675192d0ee597e7603a8d6831a3c227c inherit pub_static_methods_classBasePwm" id="r_a675192d0ee597e7603a8d6831a3c227c"><td class="memItemLeft" align="right" valign="top">static constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#a675192d0ee597e7603a8d6831a3c227c">ClampDutyCycle</a> (float duty_cycle) noexcept</td></tr>
<tr class="memdesc:a675192d0ee597e7603a8d6831a3c227c inherit pub_static_methods_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp duty cycle to valid range.  <br /></td></tr>
<tr class="separator:a675192d0ee597e7603a8d6831a3c227c inherit pub_static_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classBasePwm"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classBasePwm')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classBasePwm.html">BasePwm</a></td></tr>
<tr class="memitem:acd8c699abcc77062da2e26319dafcb0b inherit pro_methods_classBasePwm" id="r_acd8c699abcc77062da2e26319dafcb0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#acd8c699abcc77062da2e26319dafcb0b">BasePwm</a> () noexcept</td></tr>
<tr class="separator:acd8c699abcc77062da2e26319dafcb0b inherit pro_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf342e2451aa841522e07bc84c86a0a7 inherit pro_methods_classBasePwm" id="r_aaf342e2451aa841522e07bc84c86a0a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#aaf342e2451aa841522e07bc84c86a0a7">BasePwm</a> (const <a class="el" href="classBasePwm.html">BasePwm</a> &amp;)=delete</td></tr>
<tr class="separator:aaf342e2451aa841522e07bc84c86a0a7 inherit pro_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa73dc6b8bc3028f3848e0f470dec48d inherit pro_methods_classBasePwm" id="r_afa73dc6b8bc3028f3848e0f470dec48d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBasePwm.html">BasePwm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#afa73dc6b8bc3028f3848e0f470dec48d">operator=</a> (const <a class="el" href="classBasePwm.html">BasePwm</a> &amp;)=delete</td></tr>
<tr class="separator:afa73dc6b8bc3028f3848e0f470dec48d inherit pro_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98809c8d18cca38549c10e1a8616021c inherit pro_methods_classBasePwm" id="r_a98809c8d18cca38549c10e1a8616021c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#a98809c8d18cca38549c10e1a8616021c">BasePwm</a> (<a class="el" href="classBasePwm.html">BasePwm</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a98809c8d18cca38549c10e1a8616021c inherit pro_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a64fe3584550862c40531d576211b3 inherit pro_methods_classBasePwm" id="r_a61a64fe3584550862c40531d576211b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBasePwm.html">BasePwm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#a61a64fe3584550862c40531d576211b3">operator=</a> (<a class="el" href="classBasePwm.html">BasePwm</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a61a64fe3584550862c40531d576211b3 inherit pro_methods_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classBasePwm"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_classBasePwm')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classBasePwm.html">BasePwm</a></td></tr>
<tr class="memitem:a6506053d333fbed35bfea3ee3bd74693 inherit pro_attribs_classBasePwm" id="r_a6506053d333fbed35bfea3ee3bd74693"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#a6506053d333fbed35bfea3ee3bd74693">initialized_</a></td></tr>
<tr class="memdesc:a6506053d333fbed35bfea3ee3bd74693 inherit pro_attribs_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization state.  <br /></td></tr>
<tr class="separator:a6506053d333fbed35bfea3ee3bd74693 inherit pro_attribs_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8107794611a82a5cceedbaaa2b61c78 inherit pro_attribs_classBasePwm" id="r_ae8107794611a82a5cceedbaaa2b61c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhf__pwm__statistics__t.html">hf_pwm_statistics_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#ae8107794611a82a5cceedbaaa2b61c78">statistics_</a></td></tr>
<tr class="memdesc:ae8107794611a82a5cceedbaaa2b61c78 inherit pro_attribs_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM operation statistics.  <br /></td></tr>
<tr class="separator:ae8107794611a82a5cceedbaaa2b61c78 inherit pro_attribs_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0deb2d047f9df776ac3b6f0f246fc3ca inherit pro_attribs_classBasePwm" id="r_a0deb2d047f9df776ac3b6f0f246fc3ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhf__pwm__diagnostics__t.html">hf_pwm_diagnostics_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBasePwm.html#a0deb2d047f9df776ac3b6f0f246fc3ca">diagnostics_</a></td></tr>
<tr class="memdesc:a0deb2d047f9df776ac3b6f0f246fc3ca inherit pro_attribs_classBasePwm"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM diagnostic information.  <br /></td></tr>
<tr class="separator:a0deb2d047f9df776ac3b6f0f246fc3ca inherit pro_attribs_classBasePwm"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ESP32 PWM implementation using LEDC peripheral with comprehensive ESP32 variant support. </p>
<p>This class provides PWM generation using the ESP32 family's built-in LEDC (LED Controller) peripheral which offers high-resolution PWM with hardware fade support. The implementation automatically adapts to different ESP32 variants and their specific LEDC capabilities.</p>
<h2><a class="anchor" id="autotoc_md0"></a>
ESP32 Variant LEDC Capabilities:</h2>
<h3><a class="anchor" id="autotoc_md1"></a>
ESP32 (Classic):</h3>
<ul>
<li><b>Channels:</b> 16 channels (8 high-speed + 8 low-speed)</li>
<li><b>Timers:</b> 8 timers (4 high-speed + 4 low-speed)</li>
<li><b>Clock Sources:</b> APB_CLK (80MHz), REF_TICK (1MHz), RTC8M_CLK (LS only)</li>
<li><b>Resolution:</b> Up to 20-bit at low frequencies, 14-bit at high frequencies</li>
<li><b>Special Features:</b> Separate high-speed and low-speed modes</li>
</ul>
<h3><a class="anchor" id="autotoc_md2"></a>
ESP32-S2/S3:</h3>
<ul>
<li><b>Channels:</b> 8 channels (unified mode)</li>
<li><b>Timers:</b> 4 timers (unified)</li>
<li><b>Clock Sources:</b> APB_CLK (80MHz), REF_TICK (1MHz), XTAL_CLK (LS only)</li>
<li><b>Resolution:</b> Up to 14-bit resolution</li>
<li><b>Special Features:</b> Unified speed mode, improved power efficiency</li>
</ul>
<h3><a class="anchor" id="autotoc_md3"></a>
ESP32-C3/C6/H2:</h3>
<ul>
<li><b>Channels:</b> 6 channels (ESP32-C6), 6 channels (ESP32-C3), 4 channels (ESP32-H2)</li>
<li><b>Timers:</b> 4 timers (C3/C6), 2 timers (H2)</li>
<li><b>Clock Sources:</b> APB_CLK (80MHz), REF_TICK (1MHz), XTAL_CLK</li>
<li><b>Resolution:</b> Up to 14-bit resolution</li>
<li><b>Special Features:</b> Compact design, optimized for IoT applications</li>
</ul>
<h2><a class="anchor" id="autotoc_md4"></a>
Clock Source Constraints:</h2>
<p><b>CRITICAL:</b> Different ESP32 variants have different clock source limitations:</p><ul>
<li><b>ESP32 Classic:</b> Each timer can use different clock sources independently</li>
<li><b>ESP32-S2/S3/C3/C6/H2:</b> All timers typically share the same clock source</li>
<li><b>Frequency Limitations:</b> Clock source determines maximum achievable frequency:<ul>
<li>APB_CLK (80MHz): Max ~78kHz at 10-bit resolution</li>
<li>XTAL_CLK (40MHz): Max ~39kHz at 10-bit resolution</li>
<li>REF_TICK (1MHz): Max ~976Hz at 10-bit resolution</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Timer Resource Management:</h2>
<p>The LEDC peripheral uses a timer-channel architecture where:</p><ul>
<li>Multiple channels can share the same timer (same frequency/resolution)</li>
<li>Each timer supports up to 8 channels (hardware limitation)</li>
<li>Timer allocation is automatic but can be controlled manually</li>
<li>Smart eviction policies protect critical channels</li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
Key Design Features:</h2>
<ul>
<li><b>Variant-Aware:</b> Automatically detects and adapts to ESP32 variant capabilities</li>
<li><b>Thread-Safe:</b> Full <a class="el" href="classRtosMutex.html">RtosMutex</a> protection for concurrent access</li>
<li><b>Smart Timer Management:</b> Automatic allocation with conflict resolution</li>
<li><b>Hardware Fade Support:</b> Native LEDC fade functionality</li>
<li><b>Error Recovery:</b> Comprehensive fault detection and recovery mechanisms</li>
<li><b>Motor Control Ready:</b> Complementary outputs, deadtime, and synchronization</li>
<li><b>Resource Protection:</b> Eviction policies prevent accidental channel disruption</li>
<li><b>Performance Optimized:</b> Minimal overhead, efficient memory usage </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae8e7d6e7f4ca605d4d4a361dc7806fd0" name="ae8e7d6e7f4ca605d4d4a361dc7806fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e7d6e7f4ca605d4d4a361dc7806fd0">&#9670;&#160;</a></span>EspPwm() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EspPwm::EspPwm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhf__pwm__unit__config__t.html">hf_pwm_unit_config_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structhf__pwm__unit__config__t.html">hf_pwm_unit_config_t</a>{}</span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for ESP32C6 PWM controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>PWM unit configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Uses lazy initialization - no hardware action until first operation </dd></dl>

</div>
</div>
<a id="aaac5ce3f95ae8c5fb96312ad9a779ce6" name="aaac5ce3f95ae8c5fb96312ad9a779ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac5ce3f95ae8c5fb96312ad9a779ce6">&#9670;&#160;</a></span>~EspPwm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EspPwm::~EspPwm </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor - ensures clean shutdown. </p>

</div>
</div>
<a id="adda6756a1158a4cb37194c0690ac412f" name="adda6756a1158a4cb37194c0690ac412f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda6756a1158a4cb37194c0690ac412f">&#9670;&#160;</a></span>EspPwm() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EspPwm::EspPwm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEspPwm.html">EspPwm</a> &amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0523ebf8e643c95ad9b3ced6ff077fc7" name="a0523ebf8e643c95ad9b3ced6ff077fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0523ebf8e643c95ad9b3ced6ff077fc7">&#9670;&#160;</a></span>EspPwm() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">EspPwm::EspPwm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEspPwm.html">EspPwm</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6278208d17f1ae7c3dcc2c94abdc6dbd" name="a6278208d17f1ae7c3dcc2c94abdc6dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6278208d17f1ae7c3dcc2c94abdc6dbd">&#9670;&#160;</a></span>AttemptEvictionNonCritical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a88065d24fa2d174cf7b698ce5d498c44">hf_i8_t</a> EspPwm::AttemptEvictionNonCritical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>frequency_hz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>resolution_bits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt eviction of non-critical channels only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency_hz</td><td>Required frequency </td></tr>
    <tr><td class="paramname">resolution_bits</td><td>Required resolution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timer ID if successful, -1 if no non-critical timers available </dd></dl>

</div>
</div>
<a id="a351d6b815860b91b7ed60d59cf00cb39" name="a351d6b815860b91b7ed60d59cf00cb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351d6b815860b91b7ed60d59cf00cb39">&#9670;&#160;</a></span>AttemptEvictionWithConsent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a88065d24fa2d174cf7b698ce5d498c44">hf_i8_t</a> EspPwm::AttemptEvictionWithConsent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>frequency_hz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>resolution_bits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt eviction with user consent callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency_hz</td><td>Required frequency </td></tr>
    <tr><td class="paramname">resolution_bits</td><td>Required resolution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timer ID if approved and successful, -1 if denied/failed </dd></dl>

</div>
</div>
<a id="a3a3e5e9d0cf58e8c9aa9e912a5e18bb2" name="a3a3e5e9d0cf58e8c9aa9e912a5e18bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3e5e9d0cf58e8c9aa9e912a5e18bb2">&#9670;&#160;</a></span>AttemptForceEviction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a88065d24fa2d174cf7b698ce5d498c44">hf_i8_t</a> EspPwm::AttemptForceEviction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>frequency_hz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>resolution_bits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt aggressive eviction (original behavior) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency_hz</td><td>Required frequency </td></tr>
    <tr><td class="paramname">resolution_bits</td><td>Required resolution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timer ID if successful, -1 if failed </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only used with FORCE_EVICTION policy - may disrupt critical channels! </dd></dl>

</div>
</div>
<a id="a0b455ad1230974f857a6cf89cc1598fb" name="a0b455ad1230974f857a6cf89cc1598fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b455ad1230974f857a6cf89cc1598fb">&#9670;&#160;</a></span>AttemptSafeEviction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a88065d24fa2d174cf7b698ce5d498c44">hf_i8_t</a> EspPwm::AttemptSafeEviction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>frequency_hz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>resolution_bits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt safe timer eviction based on user policy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency_hz</td><td>Required frequency </td></tr>
    <tr><td class="paramname">resolution_bits</td><td>Required resolution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timer ID if eviction successful, -1 if denied/failed </dd></dl>

</div>
</div>
<a id="a6a19207d3326cb8f660670a6fa46035c" name="a6a19207d3326cb8f660670a6fa46035c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a19207d3326cb8f660670a6fa46035c">&#9670;&#160;</a></span>CalculateClockDivider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> EspPwm::CalculateClockDivider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>frequency_hz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>resolution_bits</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate optimal clock divider for frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency_hz</td><td>Target frequency </td></tr>
    <tr><td class="paramname">resolution_bits</td><td>PWM resolution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Clock divider value </dd></dl>

</div>
</div>
<a id="a1fa0af5ac18437a6235fcbdfca39b222" name="a1fa0af5ac18437a6235fcbdfca39b222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa0af5ac18437a6235fcbdfca39b222">&#9670;&#160;</a></span>CalculateMaxFrequency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> EspPwm::CalculateMaxFrequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>resolution_bits</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a></td>          <td class="paramname"><span class="paramname"><em>clock_source</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82a2fb4f97b7c1b78586a5f9f8365272822">hf_pwm_clock_source_t::HF_PWM_CLK_SRC_APB</a></span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate maximum achievable frequency for a given resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution_bits</td><td>Target resolution in bits </td></tr>
    <tr><td class="paramname">clock_source</td><td>Clock source to use (default: APB) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum frequency in Hz, or 0 if resolution too high </dd></dl>

</div>
</div>
<a id="af5a2e6d7bd1a18b68089d5f3bdea2e34" name="af5a2e6d7bd1a18b68089d5f3bdea2e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a2e6d7bd1a18b68089d5f3bdea2e34">&#9670;&#160;</a></span>CalculateMaxResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> EspPwm::CalculateMaxResolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>frequency_hz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a></td>          <td class="paramname"><span class="paramname"><em>clock_source</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82a2fb4f97b7c1b78586a5f9f8365272822">hf_pwm_clock_source_t::HF_PWM_CLK_SRC_APB</a></span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate maximum achievable resolution for a given frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency_hz</td><td>Target frequency in Hz </td></tr>
    <tr><td class="paramname">clock_source</td><td>Clock source to use (default: APB) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum resolution in bits, or 0 if frequency too high </dd></dl>

</div>
</div>
<a id="a4dc265e040617403e718d4d28ff66e56" name="a4dc265e040617403e718d4d28ff66e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc265e040617403e718d4d28ff66e56">&#9670;&#160;</a></span>ConfigureChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::ConfigureChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhf__pwm__channel__config__t.html">hf_pwm_channel_config_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure a PWM channel with comprehensive LEDC feature support. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier (0 to MAX_CHANNELS-1) </td></tr>
    <tr><td class="paramname">config</td><td>Complete channel configuration including GPIO, frequency, resolution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>This method configures a PWM channel with full LEDC peripheral integration:</p><ul>
<li><b>Timer Assignment:</b> Automatic or manual timer allocation with conflict resolution</li>
<li><b>Frequency/Resolution Validation:</b> Hardware constraint verification against clock source</li>
<li><b>GPIO Configuration:</b> Pin matrix validation and hardware setup</li>
<li><b>Resource Management:</b> Smart timer sharing and eviction policy enforcement</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The channel must be enabled separately using <a class="el" href="#a3bd515c8685db84d5ff92a475063d663" title="Enable a configured PWM channel to start signal generation.">EnableChannel()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Invalid frequency/resolution combinations will be rejected with detailed error codes</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa1e2001e94083e72e12e0bf1a6f34d77" title="Set frequency with explicit resolution choice (user-controlled)">SetFrequencyWithResolution()</a> for explicit frequency/resolution control </dd>
<dd>
<a class="el" href="#a3bd515c8685db84d5ff92a475063d663" title="Enable a configured PWM channel to start signal generation.">EnableChannel()</a> to activate the configured channel </dd></dl>

</div>
</div>
<a id="a023bc718f864eb1e2b887c4de5013fa9" name="a023bc718f864eb1e2b887c4de5013fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023bc718f864eb1e2b887c4de5013fa9">&#9670;&#160;</a></span>ConfigurePlatformChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::ConfigurePlatformChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhf__pwm__channel__config__t.html">hf_pwm_channel_config_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>timer_id</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure platform channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel to configure </td></tr>
    <tr><td class="paramname">config</td><td>Channel configuration </td></tr>
    <tr><td class="paramname">timer_id</td><td>Assigned timer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="a362d7335d05a027efd2a9429bf4d8e40" name="a362d7335d05a027efd2a9429bf4d8e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362d7335d05a027efd2a9429bf4d8e40">&#9670;&#160;</a></span>ConfigurePlatformTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::ConfigurePlatformTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>timer_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>frequency_hz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>resolution_bits</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a></td>          <td class="paramname"><span class="paramname"><em>clock_source</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure platform timer with LEDC peripheral integration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer_id</td><td>Timer identifier to configure (0 to MAX_TIMERS-1) </td></tr>
    <tr><td class="paramname">frequency_hz</td><td>Timer frequency in Hz </td></tr>
    <tr><td class="paramname">resolution_bits</td><td>Timer resolution in bits (4-14) </td></tr>
    <tr><td class="paramname">clock_source</td><td>Clock source for timer configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Configures an LEDC timer with specified parameters:</p><ul>
<li>Maps clock source enum to ESP-IDF LEDC clock configuration</li>
<li>Validates frequency/resolution combination against hardware constraints</li>
<li>Updates internal timer state for resource tracking</li>
<li>Performs actual LEDC timer hardware configuration</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Timer configuration affects all channels assigned to this timer </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Invalid combinations will cause hardware configuration failure </dd></dl>

</div>
</div>
<a id="a416e064052b50ac0175651a5e191adc4" name="a416e064052b50ac0175651a5e191adc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416e064052b50ac0175651a5e191adc4">&#9670;&#160;</a></span>DeconfigureChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::DeconfigureChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deconfigure a channel and release all associated resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel ID to deconfigure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method:<ol type="1">
<li>Stops the channel if it's enabled</li>
<li>Releases timer resources if no other channels are using it</li>
<li>Resets GPIO pin to default state</li>
<li>Completely resets channel state to unconfigured </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a28c857a39efec61ad79770770fca878c" name="a28c857a39efec61ad79770770fca878c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c857a39efec61ad79770770fca878c">&#9670;&#160;</a></span>Deinitialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::Deinitialize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deinitialize the LEDC peripheral and release all resources. </p>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Performs comprehensive cleanup and resource release:</p><ul>
<li>Stops all active PWM channels with proper idle level setting</li>
<li>Releases and resets all LEDC timers with hardware cleanup</li>
<li>Resets all GPIO pins to default state</li>
<li>Uninstalls fade functionality to prevent conflicts</li>
<li>Clears all internal state and statistics</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Safe to call multiple times or on already deinitialized instances </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>All PWM outputs will stop and GPIOs will be reset to default state</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aedb8649c68e856258d6278bf399aab05" title="Initialize the LEDC peripheral and PWM subsystem.">Initialize()</a> for PWM subsystem initialization</dd></dl>
<p>() - ESP32-specific cleanup with LEDC peripheral reset </p>

<p>Implements <a class="el" href="classBasePwm.html#a7d3dbe67ab0c23c738e2507f915137fb">BasePwm</a>.</p>

</div>
</div>
<a id="aeda4cc0ceb6d711d81989a66d2fe3596" name="aeda4cc0ceb6d711d81989a66d2fe3596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda4cc0ceb6d711d81989a66d2fe3596">&#9670;&#160;</a></span>DisableAutoFallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::DisableAutoFallback </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable automatic fallback to alternative resolutions. </p>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When disabled, <a class="el" href="#a185108e6adbaaa23bcef4fbd8bda1b91" title="Set PWM frequency with automatic timer management.">SetFrequency()</a> will fail validation for problematic combinations </dd></dl>

</div>
</div>
<a id="a8ff1addad40e1a81afa83a975b136e89" name="a8ff1addad40e1a81afa83a975b136e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff1addad40e1a81afa83a975b136e89">&#9670;&#160;</a></span>DisableChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::DisableChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable a PWM channel and stop signal generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier to disable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Stops PWM signal generation and sets output to configured idle level. Timer resources are automatically managed and released if unused.</p>
<dl class="section note"><dt>Note</dt><dd>GPIO pin will be set to the configured idle level (0 or 1) </dd></dl>

<p>Implements <a class="el" href="classBasePwm.html#a88b6b8a4d9ea7c9172846aa4e9cc572d">BasePwm</a>.</p>

</div>
</div>
<a id="a23cb19b3d0030bf788c976f05c4bd6e9" name="a23cb19b3d0030bf788c976f05c4bd6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cb19b3d0030bf788c976f05c4bd6e9">&#9670;&#160;</a></span>EnableAutoFallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::EnableAutoFallback </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable automatic fallback to alternative resolutions. </p>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>
<dl class="section note"><dt>Note</dt><dd>When enabled, <a class="el" href="#a185108e6adbaaa23bcef4fbd8bda1b91" title="Set PWM frequency with automatic timer management.">SetFrequency()</a> will automatically try alternative resolutions </dd></dl>

</div>
</div>
<a id="a3bd515c8685db84d5ff92a475063d663" name="a3bd515c8685db84d5ff92a475063d663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd515c8685db84d5ff92a475063d663">&#9670;&#160;</a></span>EnableChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::EnableChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable a configured PWM channel to start signal generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier to enable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Activates PWM signal generation on the specified channel using the LEDC peripheral. The channel must be previously configured with <a class="el" href="#a4dc265e040617403e718d4d28ff66e56" title="Configure a PWM channel with comprehensive LEDC feature support.">ConfigureChannel()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Uses fade-compatible or basic LEDC functions based on current mode </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Channel must be configured before enabling </dd></dl>

<p>Implements <a class="el" href="classBasePwm.html#af1c19d6ae43e3711a2a16dc39d8dbfa6">BasePwm</a>.</p>

</div>
</div>
<a id="a9192ec3aa26d9acac2c0e6ec30c6bed1" name="a9192ec3aa26d9acac2c0e6ec30c6bed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9192ec3aa26d9acac2c0e6ec30c6bed1">&#9670;&#160;</a></span>EnableFade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::EnableFade </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable fade functionality. </p>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="ad352f2f3a014631f98d996814c806163" name="ad352f2f3a014631f98d996814c806163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad352f2f3a014631f98d996814c806163">&#9670;&#160;</a></span>FindBestAlternativeResolutionDynamic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> EspPwm::FindBestAlternativeResolutionDynamic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>frequency_hz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>preferred_resolution</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a></td>          <td class="paramname"><span class="paramname"><em>clock_source</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82a2fb4f97b7c1b78586a5f9f8365272822">hf_pwm_clock_source_t::HF_PWM_CLK_SRC_APB</a></span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find best alternative resolution using dynamic calculation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency_hz</td><td>Target frequency in Hz </td></tr>
    <tr><td class="paramname">preferred_resolution</td><td>Preferred resolution in bits </td></tr>
    <tr><td class="paramname">clock_source</td><td>Clock source for calculation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Best alternative resolution, or preferred if no better option </dd></dl>

</div>
</div>
<a id="a8f782916b4f7d5dabe48e2c913ea98e9" name="a8f782916b4f7d5dabe48e2c913ea98e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f782916b4f7d5dabe48e2c913ea98e9">&#9670;&#160;</a></span>FindOrAllocateTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a88065d24fa2d174cf7b698ce5d498c44">hf_i8_t</a> EspPwm::FindOrAllocateTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>frequency_hz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>resolution_bits</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a></td>          <td class="paramname"><span class="paramname"><em>clock_source</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unified timer allocation with comprehensive strategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency_hz</td><td>Required frequency in Hz </td></tr>
    <tr><td class="paramname">resolution_bits</td><td>Required resolution in bits (4-14) </td></tr>
    <tr><td class="paramname">clock_source</td><td>Preferred clock source for timer configuration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timer ID (0 to MAX_TIMERS-1), or -1 if no timer available</dd></dl>
<p>Implements a multi-phase allocation strategy:</p><ol type="1">
<li><b>Optimal Reuse:</b> Find exact frequency/resolution match</li>
<li><b>Compatible Reuse:</b> Find compatible frequency within tolerance</li>
<li><b>New Allocation:</b> Allocate unused timer with validation</li>
<li><b>Health Check:</b> Clean up orphaned timers and retry</li>
<li><b>Safe Eviction:</b> Apply user-defined eviction policies</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Combines all allocation strategies for maximum efficiency </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Returns -1 if all strategies fail (no available timers) </dd></dl>

</div>
</div>
<a id="a38358269d437372bb72805e76fc151ed" name="a38358269d437372bb72805e76fc151ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38358269d437372bb72805e76fc151ed">&#9670;&#160;</a></span>ForceTimerAssignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::ForceTimerAssignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>timer_id</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force a specific timer for a channel (advanced usage) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
    <tr><td class="paramname">timer_id</td><td>Timer identifier (0-3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use with caution - automatic timer allocation is usually better </dd></dl>

</div>
</div>
<a id="af92695b9e07458d6280489d1ce3d8bdd" name="af92695b9e07458d6280489d1ce3d8bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92695b9e07458d6280489d1ce3d8bdd">&#9670;&#160;</a></span>GetCapabilities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::GetCapabilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhf__pwm__capabilities__t.html">hf_pwm_capabilities_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>capabilities</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get ESP32 variant-specific PWM capabilities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capabilities</td><td>Reference to capabilities structure to populate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Returns hardware-specific limits including channel count, timer count, maximum resolution, frequency ranges, and supported features for the current ESP32 variant.</p>
<dl class="section note"><dt>Note</dt><dd>Capabilities are determined at compile-time based on target ESP32 variant </dd></dl>

</div>
</div>
<a id="a572bf6e4c5628fb5996353922417c4bc" name="a572bf6e4c5628fb5996353922417c4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572bf6e4c5628fb5996353922417c4bc">&#9670;&#160;</a></span>GetChannelPriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="EspTypes__PWM_8h.html#ad8fbde8152ecafefd714f3a7eb8344c1">hf_pwm_channel_priority_t</a> EspPwm::GetChannelPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get channel priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Channel priority, or PRIORITY_NORMAL if channel not configured </dd></dl>

</div>
</div>
<a id="a7cf9c46011b383820a588a9f153dfc52" name="a7cf9c46011b383820a588a9f153dfc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf9c46011b383820a588a9f153dfc52">&#9670;&#160;</a></span>GetChannelStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::GetChannelStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhf__pwm__channel__status__t.html">hf_pwm_channel_status_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get comprehensive channel status and configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier to query </td></tr>
    <tr><td class="paramname">status</td><td>Reference to status structure to populate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Provides complete channel state including enabled status, current settings, resolution, raw duty value, and error state for diagnostic purposes.</p>
<dl class="section note"><dt>Note</dt><dd>Status structure is zeroed on error or for unconfigured channels </dd></dl>

</div>
</div>
<a id="a81bc4616d9447ad43ec6d6c732049b59" name="a81bc4616d9447ad43ec6d6c732049b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bc4616d9447ad43ec6d6c732049b59">&#9670;&#160;</a></span>GetDiagnostics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::GetDiagnostics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhf__pwm__diagnostics__t.html">hf_pwm_diagnostics_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>diagnostics</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get PWM diagnostics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diagnostics</td><td>Diagnostics structure to fill </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

<p>Reimplemented from <a class="el" href="classBasePwm.html#a752841609c8cd458ee658579dd7f60c6">BasePwm</a>.</p>

</div>
</div>
<a id="aeb3eda73cca25d298a3c7e3cbf133f03" name="aeb3eda73cca25d298a3c7e3cbf133f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3eda73cca25d298a3c7e3cbf133f03">&#9670;&#160;</a></span>GetDutyCycle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float EspPwm::GetDutyCycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current duty cycle as a percentage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current duty cycle (0.0 to 1.0), or 0.0 if channel not configured</dd></dl>
<p>Reads the current LEDC timer compare value and converts to percentage based on the channel's current resolution setting.</p>
<dl class="section note"><dt>Note</dt><dd>Returns 0.0 for unconfigured channels or on error </dd></dl>

<p>Implements <a class="el" href="classBasePwm.html#a7d04dac1cdbfc50884b24b912a52b877">BasePwm</a>.</p>

</div>
</div>
<a id="a6bf8969af578c46e95a7b16552c3442a" name="a6bf8969af578c46e95a7b16552c3442a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf8969af578c46e95a7b16552c3442a">&#9670;&#160;</a></span>GetEvictionPolicy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="EspTypes__PWM_8h.html#ac87a4c9f233c95c6036c956aa21fdf72">hf_pwm_eviction_policy_t</a> EspPwm::GetEvictionPolicy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current eviction policy. </p>
<dl class="section return"><dt>Returns</dt><dd>Current eviction policy </dd></dl>

</div>
</div>
<a id="a4687559ad8744ece1ef578796b21eb02" name="a4687559ad8744ece1ef578796b21eb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4687559ad8744ece1ef578796b21eb02">&#9670;&#160;</a></span>GetFrequency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#ae68c5caacf4873c3a0df851e11657bbc">hf_frequency_hz_t</a> EspPwm::GetFrequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current PWM frequency in Hz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current frequency in Hz, or 0 if channel not configured</dd></dl>
<p>Returns the frequency of the timer assigned to this channel. Multiple channels sharing the same timer will return the same frequency.</p>
<dl class="section note"><dt>Note</dt><dd>Returns 0 for unconfigured channels or on error </dd></dl>

<p>Implements <a class="el" href="classBasePwm.html#a9be813122b797d0a45c3248f0c203063">BasePwm</a>.</p>

</div>
</div>
<a id="a1e5a6eaafc83ba4ac56718fcded72d81" name="a1e5a6eaafc83ba4ac56718fcded72d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5a6eaafc83ba4ac56718fcded72d81">&#9670;&#160;</a></span>GetLastError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::GetLastError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last error code for a specific channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last error code for this channel, or PWM_ERR_INVALID_CHANNEL for invalid ID</dd></dl>
<p>Each channel maintains its own error state for detailed error tracking. Useful for debugging channel-specific issues in multi-channel applications.</p>
<dl class="section note"><dt>Note</dt><dd>Error state is cleared on successful operations </dd></dl>

</div>
</div>
<a id="a620e13937a4213f8c44219272302a1a7" name="a620e13937a4213f8c44219272302a1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620e13937a4213f8c44219272302a1a7">&#9670;&#160;</a></span>GetMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="EspTypes__PWM_8h.html#aa74b1b34478ef0fde22cd029366ab3fa">hf_pwm_mode_t</a> EspPwm::GetMode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current PWM operating mode. </p>
<dl class="section return"><dt>Returns</dt><dd>Current operating mode </dd></dl>

</div>
</div>
<a id="a038775414699ae7a63277c2050ff7545" name="a038775414699ae7a63277c2050ff7545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038775414699ae7a63277c2050ff7545">&#9670;&#160;</a></span>GetResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> EspPwm::GetResolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current PWM resolution for a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current resolution in bits, or 0 on error </dd></dl>

</div>
</div>
<a id="ab9124b114f15aa018720cff258fe4bda" name="ab9124b114f15aa018720cff258fe4bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9124b114f15aa018720cff258fe4bda">&#9670;&#160;</a></span>GetSourceClockFrequency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> EspPwm::GetSourceClockFrequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a></td>          <td class="paramname"><span class="paramname"><em>clock_source</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get source clock frequency for a given clock source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clock_source</td><td>Clock source to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Clock frequency in Hz </dd></dl>

</div>
</div>
<a id="a9ff4ddc5a06060a4b7194154a7d28617" name="a9ff4ddc5a06060a4b7194154a7d28617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff4ddc5a06060a4b7194154a7d28617">&#9670;&#160;</a></span>GetStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::GetStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhf__pwm__statistics__t.html">hf_pwm_statistics_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>statistics</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get PWM statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">statistics</td><td>Statistics structure to fill </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

<p>Reimplemented from <a class="el" href="classBasePwm.html#a7802bfabb7ac9430764bce70cbf03758">BasePwm</a>.</p>

</div>
</div>
<a id="a4437f86f7dfc052c9abd0cd633c10e71" name="a4437f86f7dfc052c9abd0cd633c10e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4437f86f7dfc052c9abd0cd633c10e71">&#9670;&#160;</a></span>GetTimerAssignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a88065d24fa2d174cf7b698ce5d498c44">hf_i8_t</a> EspPwm::GetTimerAssignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current timer assignment for a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timer number (0-3), or -1 if channel not configured </dd></dl>

</div>
</div>
<a id="a981f330beac42c81c414ccc57606a894" name="a981f330beac42c81c414ccc57606a894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981f330beac42c81c414ccc57606a894">&#9670;&#160;</a></span>GetTimerUsageInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string EspPwm::GetTimerUsageInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>timer_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get timer usage information for debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer_id</td><td>Timer to get info for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String with timer usage information </dd></dl>

</div>
</div>
<a id="af0c248eb7f9a03bf23e992c4f75b46fc" name="af0c248eb7f9a03bf23e992c4f75b46fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c248eb7f9a03bf23e992c4f75b46fc">&#9670;&#160;</a></span>HandleFadeComplete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EspPwm::HandleFadeComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle fade complete interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel that completed fade </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedb8649c68e856258d6278bf399aab05" name="aedb8649c68e856258d6278bf399aab05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb8649c68e856258d6278bf399aab05">&#9670;&#160;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::Initialize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the LEDC peripheral and PWM subsystem. </p>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Performs comprehensive LEDC peripheral initialization:</p><ul>
<li>Initializes timer and channel state arrays</li>
<li>Sets up fade functionality if enabled in configuration</li>
<li>Validates ESP32 variant capabilities</li>
<li>Prepares resource management systems</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This method is called automatically by <a class="el" href="classBasePwm.html#aa084e73274f2f1d1d67cff793eda1956" title="Ensure PWM is initialized (lazy initialization pattern)">EnsureInitialized()</a> (lazy initialization) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Multiple calls return PWM_ERR_ALREADY_INITIALIZED (safe to call repeatedly)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a28c857a39efec61ad79770770fca878c" title="Deinitialize the LEDC peripheral and release all resources.">Deinitialize()</a> for cleanup and resource release</dd></dl>
<p>() - ESP32-specific implementation using LEDC peripheral </p>

<p>Implements <a class="el" href="classBasePwm.html#a4dba77ec0b1d096f85af2288f121f7f7">BasePwm</a>.</p>

</div>
</div>
<a id="ab8ee8dcae85c2b59b80dbc996522a7b2" name="ab8ee8dcae85c2b59b80dbc996522a7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ee8dcae85c2b59b80dbc996522a7b2">&#9670;&#160;</a></span>InitializeChannels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::InitializeChannels </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize PWM channels. </p>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="abfd65e0509706ecefd541b8546596469" name="abfd65e0509706ecefd541b8546596469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd65e0509706ecefd541b8546596469">&#9670;&#160;</a></span>InitializeFadeFunctionality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::InitializeFadeFunctionality </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize LEDC fade functionality. </p>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="ae9e920ee5ebeced7fbe9dd8a80622605" name="ae9e920ee5ebeced7fbe9dd8a80622605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e920ee5ebeced7fbe9dd8a80622605">&#9670;&#160;</a></span>InitializeTimers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::InitializeTimers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize PWM timers. </p>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="a48b2831d8333eeedead0a65ca3d5af08" name="a48b2831d8333eeedead0a65ca3d5af08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b2831d8333eeedead0a65ca3d5af08">&#9670;&#160;</a></span>InterruptHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IRAM_ATTR EspPwm::InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_data</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Platform-specific interrupt handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel that generated interrupt </td></tr>
    <tr><td class="paramname">user_data</td><td>User data passed to interrupt handler (<a class="el" href="classEspPwm.html" title="ESP32 PWM implementation using LEDC peripheral with comprehensive ESP32 variant support.">EspPwm</a> instance) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb0842868ea3508b65542b2b3c46b155" name="adb0842868ea3508b65542b2b3c46b155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0842868ea3508b65542b2b3c46b155">&#9670;&#160;</a></span>IsAutoFallbackEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EspPwm::IsAutoFallbackEnabled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if auto-fallback mode is enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>true if auto-fallback is enabled, false otherwise </dd></dl>

</div>
</div>
<a id="a85c715fe2272e8c1dc93e47f44ab56ac" name="a85c715fe2272e8c1dc93e47f44ab56ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c715fe2272e8c1dc93e47f44ab56ac">&#9670;&#160;</a></span>IsChannelCritical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EspPwm::IsChannelCritical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if channel is marked as critical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if channel is critical, false otherwise </dd></dl>

</div>
</div>
<a id="a07c737787080435a486d47ad3c6803e9" name="a07c737787080435a486d47ad3c6803e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c737787080435a486d47ad3c6803e9">&#9670;&#160;</a></span>IsChannelEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EspPwm::IsChannelEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a PWM channel is currently enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if channel is enabled and generating PWM signals, false otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Returns false for unconfigured channels or channels that failed to enable </dd></dl>

<p>Implements <a class="el" href="classBasePwm.html#af2f490b963644ca04d4750b7d947b543">BasePwm</a>.</p>

</div>
</div>
<a id="a0e5f74505d1c596936c02d9f2c465158" name="a0e5f74505d1c596936c02d9f2c465158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5f74505d1c596936c02d9f2c465158">&#9670;&#160;</a></span>IsClockSourceCompatible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EspPwm::IsClockSourceCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a></td>          <td class="paramname"><span class="paramname"><em>timer_clock</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a></td>          <td class="paramname"><span class="paramname"><em>requested_clock</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two clock sources are compatible for timer sharing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer_clock</td><td>Current timer's clock source </td></tr>
    <tr><td class="paramname">requested_clock</td><td>Requested clock source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if compatible (can share timer), false otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>AUTO clock is compatible with any specific clock </dd></dl>

</div>
</div>
<a id="a7006101d1efdbfa70c2b65604ded7b85" name="a7006101d1efdbfa70c2b65604ded7b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7006101d1efdbfa70c2b65604ded7b85">&#9670;&#160;</a></span>IsFadeActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EspPwm::IsFadeActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if hardware fade is active on a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if fade is active, false otherwise </dd></dl>

</div>
</div>
<a id="a4fcc3a06cf3ba05f0f0524257d9ebf0d" name="a4fcc3a06cf3ba05f0f0524257d9ebf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcc3a06cf3ba05f0f0524257d9ebf0d">&#9670;&#160;</a></span>IsValidChannelId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EspPwm::IsValidChannelId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate channel ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel to validate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid, false otherwise </dd></dl>

</div>
</div>
<a id="aa2f60f5e67b3db043af66624f022e7b2" name="aa2f60f5e67b3db043af66624f022e7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f60f5e67b3db043af66624f022e7b2">&#9670;&#160;</a></span>LedcFadeEndCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool IRAM_ATTR EspPwm::LedcFadeEndCallback </td>
          <td>(</td>
          <td class="paramtype">const ledc_cb_param_t *</td>          <td class="paramname"><span class="paramname"><em>param</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_arg</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static ESP-IDF LEDC fade callback handler (C-compatible) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>ESP-IDF callback parameter structure </td></tr>
    <tr><td class="paramname">user_arg</td><td>User argument (<a class="el" href="classEspPwm.html" title="ESP32 PWM implementation using LEDC peripheral with comprehensive ESP32 variant support.">EspPwm</a> instance pointer) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if high priority task was woken up, false otherwise </dd></dl>

</div>
</div>
<a id="a6da40e9d83cc49cbf26f5ac4e4c3f665" name="a6da40e9d83cc49cbf26f5ac4e4c3f665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da40e9d83cc49cbf26f5ac4e4c3f665">&#9670;&#160;</a></span>NotifyTimerReconfiguration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EspPwm::NotifyTimerReconfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>timer_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>new_frequency</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>resolution_bits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify channels that their timer has been reconfigured. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer_id</td><td>Timer that was reconfigured </td></tr>
    <tr><td class="paramname">new_frequency</td><td>New frequency </td></tr>
    <tr><td class="paramname">resolution_bits</td><td>New resolution in bits </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae46e009618632e0db573912f71c94f9c" name="ae46e009618632e0db573912f71c94f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46e009618632e0db573912f71c94f9c">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEspPwm.html">EspPwm</a> &amp; EspPwm::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEspPwm.html">EspPwm</a> &amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecba3137a0ead8abc259ab199648148b" name="aecba3137a0ead8abc259ab199648148b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecba3137a0ead8abc259ab199648148b">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEspPwm.html">EspPwm</a> &amp; EspPwm::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEspPwm.html">EspPwm</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4836d32ff7c987bf03f403fa3f7ee660" name="a4836d32ff7c987bf03f403fa3f7ee660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4836d32ff7c987bf03f403fa3f7ee660">&#9670;&#160;</a></span>PerformTimerHealthCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> EspPwm::PerformTimerHealthCheck </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform comprehensive timer health check and cleanup. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of timers cleaned up </dd></dl>

</div>
</div>
<a id="a3189d43f89c413fbf2b047339b9d8eed" name="a3189d43f89c413fbf2b047339b9d8eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3189d43f89c413fbf2b047339b9d8eed">&#9670;&#160;</a></span>RegisterLedcFadeCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::RegisterLedcFadeCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register LEDC fade callback using ESP-IDF API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel to register callback for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="aecd0e9059cb48af8c52140ff2ac7cf8c" name="aecd0e9059cb48af8c52140ff2ac7cf8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd0e9059cb48af8c52140ff2ac7cf8c">&#9670;&#160;</a></span>ReleaseTimerIfUnused()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EspPwm::ReleaseTimerIfUnused </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>timer_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a timer if no longer needed with hardware cleanup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer_id</td><td>Timer to potentially release </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b222f44fa892e931bda82929f123d54" name="a7b222f44fa892e931bda82929f123d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b222f44fa892e931bda82929f123d54">&#9670;&#160;</a></span>SetChannelCritical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetChannelCritical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_critical</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark channel as critical (never evict) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
    <tr><td class="paramname">is_critical</td><td>True to protect from eviction, false to allow </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="a6b4f2fafd78318e313ced753414f11d2" name="a6b4f2fafd78318e313ced753414f11d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4f2fafd78318e313ced753414f11d2">&#9670;&#160;</a></span>SetChannelError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EspPwm::SetChannelError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a></td>          <td class="paramname"><span class="paramname"><em>error</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set error for a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
    <tr><td class="paramname">error</td><td>Error to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a543f85cebac06d91b5ac4fe7d6f325d6" name="a543f85cebac06d91b5ac4fe7d6f325d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543f85cebac06d91b5ac4fe7d6f325d6">&#9670;&#160;</a></span>SetChannelFadeCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetChannelFadeCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set per-channel callback for PWM fade completion events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier to set callback for </td></tr>
    <tr><td class="paramname">callback</td><td>Function to call on fade completion (or nullptr to disable) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Registers a per-channel callback function that is triggered when a hardware fade operation completes on the specified channel. This uses the native ESP32-C6 LEDC fade completion interrupt mechanism.</p>
<p><b>Fade Completion Detection:</b></p><ul>
<li><b>LEDC Hardware Interrupt:</b> Native ESP32-C6 fade completion interrupt</li>
<li><b>Per-Channel Granularity:</b> Each channel can have its own fade callback</li>
<li><b>Automatic Registration:</b> Uses <code>ledc_cb_register()</code> for proper ESP-IDF integration</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This callback is only triggered for hardware fade operations (<a class="el" href="#a9fb67c853d1d7d042a047fbc22ae67c5" title="Set hardware fade for smooth duty cycle transitions.">SetHardwareFade()</a>) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Callback functions should be ISR-safe and execute quickly (&lt; 10s recommended) </dd>
<dd>
Do not call blocking functions or start new fade operations in the callback</dd></dl>
<p><b>Example Usage:</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> my_fade_callback(<a class="code hl_typedef" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a> channel) {</div>
<div class="line">    <span class="comment">// ISR-safe operations only</span></div>
<div class="line">    fade_complete_flags |= (1 &lt;&lt; channel); <span class="comment">// Set completion flag</span></div>
<div class="line">    <span class="comment">// Signal task, update state, etc.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">pwm.SetChannelFadeCallback(0, my_fade_callback);</div>
<div class="line">pwm.SetHardwareFade(0, 0.8f, 1000); <span class="comment">// Fade will trigger callback when complete</span></div>
<div class="ttc" id="aHardwareTypes_8h_html_ae0889610252306068bb566d31b5494c7"><div class="ttname"><a href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></div><div class="ttdeci">hf_u32_t hf_channel_id_t</div><div class="ttdoc">Platform-agnostic channel identifier type.</div><div class="ttdef"><b>Definition</b> HardwareTypes.h:154</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a9fb67c853d1d7d042a047fbc22ae67c5" title="Set hardware fade for smooth duty cycle transitions.">SetHardwareFade()</a> for hardware fade operations </dd></dl>

</div>
</div>
<a id="a77340b2ecd211629ea79e7d9f151e063" name="a77340b2ecd211629ea79e7d9f151e063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77340b2ecd211629ea79e7d9f151e063">&#9670;&#160;</a></span>SetChannelPriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetChannelPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="EspTypes__PWM_8h.html#ad8fbde8152ecafefd714f3a7eb8344c1">hf_pwm_channel_priority_t</a></td>          <td class="paramname"><span class="paramname"><em>priority</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set channel priority for eviction decisions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
    <tr><td class="paramname">priority</td><td>Priority level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="a6c4cc0b3c19e7258a063b1900f9d291a" name="a6c4cc0b3c19e7258a063b1900f9d291a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4cc0b3c19e7258a063b1900f9d291a">&#9670;&#160;</a></span>SetComplementaryOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetComplementaryOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>primary_channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>complementary_channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>deadtime_ns</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure complementary PWM output pair with deadtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primary_channel</td><td>Primary channel identifier </td></tr>
    <tr><td class="paramname">complementary_channel</td><td>Complementary channel identifier </td></tr>
    <tr><td class="paramname">deadtime_ns</td><td>Deadtime between transitions in nanoseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Creates a complementary PWM pair where outputs are never high simultaneously. Deadtime prevents shoot-through in power electronics applications.</p>
<dl class="section note"><dt>Note</dt><dd>Both channels must be configured and use the same timer </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Complementary operation is implemented in software, not hardware</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4dc265e040617403e718d4d28ff66e56" title="Configure a PWM channel with comprehensive LEDC feature support.">ConfigureChannel()</a> to set up both channels before pairing</dd></dl>
<p>() - Software-based complementary PWM for motor control </p>

<p>Implements <a class="el" href="classBasePwm.html#a4b7f8834e3f06fbf5995b3bfd3e7aa71">BasePwm</a>.</p>

</div>
</div>
<a id="ae4170c3b4661c0d4b9646eb3d775c88c" name="ae4170c3b4661c0d4b9646eb3d775c88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4170c3b4661c0d4b9646eb3d775c88c">&#9670;&#160;</a></span>SetDutyCycle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetDutyCycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>duty_cycle</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM duty cycle as a percentage (0.0 to 1.0) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier to update </td></tr>
    <tr><td class="paramname">duty_cycle</td><td>Duty cycle as percentage (0.0 = 0%, 1.0 = 100%) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Converts percentage to raw value based on channel's current resolution and updates the LEDC peripheral. Supports both fade and basic modes.</p>
<dl class="section note"><dt>Note</dt><dd>Duty cycle is automatically clamped to valid range [0.0, 1.0] </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Channel must be configured and enabled for immediate effect </dd></dl>

<p>Implements <a class="el" href="classBasePwm.html#a4883325ace0e9fd9d096fc87a24317c3">BasePwm</a>.</p>

</div>
</div>
<a id="a6bc8906d106762d5c9b1bcfd68ff0636" name="a6bc8906d106762d5c9b1bcfd68ff0636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc8906d106762d5c9b1bcfd68ff0636">&#9670;&#160;</a></span>SetDutyCycleRaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetDutyCycleRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>raw_value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM duty cycle using raw timer counts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier to update </td></tr>
    <tr><td class="paramname">raw_value</td><td>Raw duty cycle value (0 to (2^resolution - 1)) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Directly sets LEDC timer compare value for maximum precision. Value is validated against current channel resolution.</p>
<dl class="section note"><dt>Note</dt><dd>Raw value is clamped to maximum for current resolution </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Use <a class="el" href="#a038775414699ae7a63277c2050ff7545" title="Get current PWM resolution for a channel.">GetResolution()</a> to determine valid raw value range </dd></dl>

<p>Implements <a class="el" href="classBasePwm.html#aa9f97e6e7c9af42aae99b8aeae5e7c67">BasePwm</a>.</p>

</div>
</div>
<a id="a90f27ca6f4deb563c66b584604bee706" name="a90f27ca6f4deb563c66b584604bee706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f27ca6f4deb563c66b584604bee706">&#9670;&#160;</a></span>SetEvictionCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetEvictionCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="EspTypes__PWM_8h.html#aa88988c1a4ef6005d3f20421ecba42ed">hf_pwm_eviction_callback_t</a></td>          <td class="paramname"><span class="paramname"><em>callback</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>user_data</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set eviction consent callback for user-controlled eviction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Callback function to approve/deny eviction requests </td></tr>
    <tr><td class="paramname">user_data</td><td>User data passed to callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only used when policy is ALLOW_EVICTION_WITH_CONSENT </dd></dl>

</div>
</div>
<a id="a57006756d21e8f6b6c6c65c919b991e0" name="a57006756d21e8f6b6c6c65c919b991e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57006756d21e8f6b6c6c65c919b991e0">&#9670;&#160;</a></span>SetEvictionPolicy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetEvictionPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="EspTypes__PWM_8h.html#ac87a4c9f233c95c6036c956aa21fdf72">hf_pwm_eviction_policy_t</a></td>          <td class="paramname"><span class="paramname"><em>policy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set timer eviction policy for resource management. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>Eviction policy to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Default is STRICT_NO_EVICTION for safety </dd></dl>

</div>
</div>
<a id="a185108e6adbaaa23bcef4fbd8bda1b91" name="a185108e6adbaaa23bcef4fbd8bda1b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185108e6adbaaa23bcef4fbd8bda1b91">&#9670;&#160;</a></span>SetFrequency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetFrequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae68c5caacf4873c3a0df851e11657bbc">hf_frequency_hz_t</a></td>          <td class="paramname"><span class="paramname"><em>frequency_hz</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM frequency with automatic timer management. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier to update </td></tr>
    <tr><td class="paramname">frequency_hz</td><td>Target frequency in Hz </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Automatically manages timer allocation and sharing for efficient resource usage. May trigger timer reconfiguration or reallocation if frequency change is significant.</p>
<dl class="section note"><dt>Note</dt><dd>Frequency is validated against current resolution and clock source </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Large frequency changes may affect other channels sharing the same timer</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa1e2001e94083e72e12e0bf1a6f34d77" title="Set frequency with explicit resolution choice (user-controlled)">SetFrequencyWithResolution()</a> for explicit frequency/resolution control </dd>
<dd>
<a class="el" href="#a23cb19b3d0030bf788c976f05c4bd6e9" title="Enable automatic fallback to alternative resolutions.">EnableAutoFallback()</a> for automatic resolution adjustment </dd></dl>

<p>Implements <a class="el" href="classBasePwm.html#ad192230babf2e4dc7a37477b4a0153b8">BasePwm</a>.</p>

</div>
</div>
<a id="aa98797ac6975b2f6ec3c297113bbf99d" name="aa98797ac6975b2f6ec3c297113bbf99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98797ac6975b2f6ec3c297113bbf99d">&#9670;&#160;</a></span>SetFrequencyAndResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetFrequencyAndResolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae68c5caacf4873c3a0df851e11657bbc">hf_frequency_hz_t</a></td>          <td class="paramname"><span class="paramname"><em>frequency_hz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>resolution_bits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set frequency and resolution together (atomic operation) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
    <tr><td class="paramname">frequency_hz</td><td>Frequency in Hz </td></tr>
    <tr><td class="paramname">resolution_bits</td><td>Resolution in bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is the most efficient way to change both parameters simultaneously </dd></dl>

</div>
</div>
<a id="abe00eaeddf0a329994bdebf61d3439f9" name="abe00eaeddf0a329994bdebf61d3439f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe00eaeddf0a329994bdebf61d3439f9">&#9670;&#160;</a></span>SetFrequencyWithAutoFallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetFrequencyWithAutoFallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae68c5caacf4873c3a0df851e11657bbc">hf_frequency_hz_t</a></td>          <td class="paramname"><span class="paramname"><em>frequency_hz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>preferred_resolution</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set frequency with automatic fallback to alternative resolutions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
    <tr><td class="paramname">frequency_hz</td><td>Target frequency in Hz </td></tr>
    <tr><td class="paramname">preferred_resolution</td><td>Preferred resolution in bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically tries alternative resolutions if preferred fails </dd></dl>

</div>
</div>
<a id="aa1e2001e94083e72e12e0bf1a6f34d77" name="aa1e2001e94083e72e12e0bf1a6f34d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e2001e94083e72e12e0bf1a6f34d77">&#9670;&#160;</a></span>SetFrequencyWithResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetFrequencyWithResolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae68c5caacf4873c3a0df851e11657bbc">hf_frequency_hz_t</a></td>          <td class="paramname"><span class="paramname"><em>frequency_hz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>resolution_bits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set frequency with explicit resolution choice (user-controlled) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
    <tr><td class="paramname">frequency_hz</td><td>Target frequency in Hz </td></tr>
    <tr><td class="paramname">resolution_bits</td><td>Explicit resolution choice in bits (4-14) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>This method allows precise control over both frequency and resolution. The combination is validated against LEDC hardware constraints:</p><ul>
<li><b>Formula:</b> Required Clock = frequency_hz  (2^resolution_bits)</li>
<li><b>APB Clock (80MHz):</b> Max frequency = 80MHz / (2^resolution_bits)</li>
<li><b>Example:</b> 1kHz @ 10-bit requires 1.024MHz (1.28% of 80MHz) </li>
<li><b>Example:</b> 100kHz @ 10-bit requires 102.4MHz (128% of 80MHz) </li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>This method performs strict validation and will fail if the frequency/resolution combination exceeds hardware capabilities. Use <a class="el" href="#abe00eaeddf0a329994bdebf61d3439f9" title="Set frequency with automatic fallback to alternative resolutions.">SetFrequencyWithAutoFallback()</a> for automatic resolution adjustment. </dd></dl>

</div>
</div>
<a id="a9fb67c853d1d7d042a047fbc22ae67c5" name="a9fb67c853d1d7d042a047fbc22ae67c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb67c853d1d7d042a047fbc22ae67c5">&#9670;&#160;</a></span>SetHardwareFade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetHardwareFade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>target_duty_cycle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>fade_time_ms</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set hardware fade for smooth duty cycle transitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
    <tr><td class="paramname">target_duty_cycle</td><td>Target duty cycle (0.0 - 1.0) </td></tr>
    <tr><td class="paramname">fade_time_ms</td><td>Fade duration in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="a1d72b937ecff8d06181a2a0e7c7cb314" name="a1d72b937ecff8d06181a2a0e7c7cb314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d72b937ecff8d06181a2a0e7c7cb314">&#9670;&#160;</a></span>SetIdleLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetIdleLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>idle_level</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set idle output level for a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
    <tr><td class="paramname">idle_level</td><td>Idle level (0 or 1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="a848d38996b427bf51215bf0c0147a328" name="a848d38996b427bf51215bf0c0147a328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848d38996b427bf51215bf0c0147a328">&#9670;&#160;</a></span>SetMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="EspTypes__PWM_8h.html#aa74b1b34478ef0fde22cd029366ab3fa">hf_pwm_mode_t</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM operating mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Operating mode (Basic or Fade) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="a6096fdc1d06345204c8062d2f86bd0c5" name="a6096fdc1d06345204c8062d2f86bd0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6096fdc1d06345204c8062d2f86bd0c5">&#9670;&#160;</a></span>SetPhaseShift()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetPhaseShift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>phase_shift_degrees</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM phase shift (ESP32 LEDC limitation: not supported) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier (unused) </td></tr>
    <tr><td class="paramname">phase_shift_degrees</td><td>Phase shift in degrees (unused) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_ERR_INVALID_PARAMETER (LEDC doesn't support phase shift)</dd></dl>
<p>The ESP32 LEDC peripheral does not support hardware phase shifting. This method is provided for interface compatibility but will always return an error.</p>
<dl class="section note"><dt>Note</dt><dd>For phase relationships, consider using timer offsets or software timing </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method will always fail on ESP32 LEDC peripheral</dd></dl>
<p>() - Required by base class interface but not supported by ESP32 LEDC hardware </p>

<p>Implements <a class="el" href="classBasePwm.html#ad2d69c4057b84358f120f1c27fb3e2c1">BasePwm</a>.</p>

</div>
</div>
<a id="ae2795158cb647453ec43de6f9848417b" name="ae2795158cb647453ec43de6f9848417b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2795158cb647453ec43de6f9848417b">&#9670;&#160;</a></span>SetResolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::SetResolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>resolution_bits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM resolution for a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
    <tr><td class="paramname">resolution_bits</td><td>Resolution in bits (4-14) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This may require timer reallocation if resolution changes significantly </dd></dl>

</div>
</div>
<a id="a130153d9f4bdaee4219736cb248d78f6" name="a130153d9f4bdaee4219736cb248d78f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130153d9f4bdaee4219736cb248d78f6">&#9670;&#160;</a></span>StartAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::StartAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start all configured PWM channels simultaneously. </p>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Enables all configured channels in a coordinated manner for synchronized startup. Channels that are already enabled remain unaffected.</p>
<dl class="section note"><dt>Note</dt><dd>Only affects channels that have been configured with <a class="el" href="#a4dc265e040617403e718d4d28ff66e56" title="Configure a PWM channel with comprehensive LEDC feature support.">ConfigureChannel()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Individual channel errors are logged but don't stop the overall operation </dd></dl>

<p>Implements <a class="el" href="classBasePwm.html#a02e791636c4d544d702b06014695ed31">BasePwm</a>.</p>

</div>
</div>
<a id="a8be25ecab27ff61499a66535f303df2e" name="a8be25ecab27ff61499a66535f303df2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be25ecab27ff61499a66535f303df2e">&#9670;&#160;</a></span>StopAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::StopAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop all enabled PWM channels simultaneously. </p>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Disables all enabled channels in a coordinated manner for synchronized shutdown. Each channel's GPIO will be set to its configured idle level.</p>
<dl class="section note"><dt>Note</dt><dd>Timer resources are automatically managed and released as appropriate </dd></dl>

<p>Implements <a class="el" href="classBasePwm.html#a0dc5b8704b7f3107745224441d7b3a5b">BasePwm</a>.</p>

</div>
</div>
<a id="ab3d06a21a6eda6c081f660895d81bbb1" name="ab3d06a21a6eda6c081f660895d81bbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d06a21a6eda6c081f660895d81bbb1">&#9670;&#160;</a></span>StopHardwareFade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::StopHardwareFade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop hardware fade for a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="a51e0799a5758dd6159e417fcf00c5d31" name="a51e0799a5758dd6159e417fcf00c5d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e0799a5758dd6159e417fcf00c5d31">&#9670;&#160;</a></span>UnregisterLedcFadeCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::UnregisterLedcFadeCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregister LEDC fade callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel to unregister callback for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="a5681d5ceb230b6dc0a459f3ef9630b8b" name="a5681d5ceb230b6dc0a459f3ef9630b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5681d5ceb230b6dc0a459f3ef9630b8b">&#9670;&#160;</a></span>UpdateAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::UpdateAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update all enabled PWM channels with their current settings. </p>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure</dd></dl>
<p>Forces a synchronized update of all active LEDC channels to ensure any pending duty cycle or configuration changes take effect simultaneously.</p>
<dl class="section note"><dt>Note</dt><dd>Useful after multiple <a class="el" href="#ae4170c3b4661c0d4b9646eb3d775c88c" title="Set PWM duty cycle as a percentage (0.0 to 1.0)">SetDutyCycle()</a> calls to ensure synchronized updates </dd></dl>

<p>Implements <a class="el" href="classBasePwm.html#a9cb4de783416fab169872c9250d30089">BasePwm</a>.</p>

</div>
</div>
<a id="aeb62a6be326c25671cc8780618902cd4" name="aeb62a6be326c25671cc8780618902cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb62a6be326c25671cc8780618902cd4">&#9670;&#160;</a></span>UpdatePlatformDuty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::UpdatePlatformDuty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#ae0889610252306068bb566d31b5494c7">hf_channel_id_t</a></td>          <td class="paramname"><span class="paramname"><em>channel_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>raw_duty_value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update platform duty cycle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel_id</td><td>Channel to update </td></tr>
    <tr><td class="paramname">raw_duty_value</td><td>Raw duty value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PWM_SUCCESS on success, error code on failure </dd></dl>

</div>
</div>
<a id="aa3662ff3251aebe8026b16bef3773420" name="aa3662ff3251aebe8026b16bef3773420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3662ff3251aebe8026b16bef3773420">&#9670;&#160;</a></span>ValidateDutyCycleRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EspPwm::ValidateDutyCycleRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a></td>          <td class="paramname"><span class="paramname"><em>raw_duty</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a></td>          <td class="paramname"><span class="paramname"><em>resolution_bits</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enhanced duty cycle validation with overflow protection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw_duty</td><td>Raw duty cycle value </td></tr>
    <tr><td class="paramname">resolution_bits</td><td>Resolution in bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if duty cycle is valid and safe </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Implements ESP-IDF overflow protection: duty &lt; 2^resolution </dd></dl>

</div>
</div>
<a id="abd81092951838b5058abd3db6ad7a0af" name="abd81092951838b5058abd3db6ad7a0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd81092951838b5058abd3db6ad7a0af">&#9670;&#160;</a></span>ValidateFrequencyResolutionComplete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEspPwm_1_1ValidationResult.html">EspPwm::ValidationResult</a> EspPwm::ValidateFrequencyResolutionComplete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEspPwm_1_1ValidationContext.html">ValidationContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unified comprehensive validation for frequency/resolution combinations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Validation context with all parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Detailed validation result with recommendations </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This replaces all individual validation functions with a unified approach </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1f3b42702956b65454339f9a61458806" name="a1f3b42702956b65454339f9a61458806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3b42702956b65454339f9a61458806">&#9670;&#160;</a></span>auto_fallback_enabled_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EspPwm::auto_fallback_enabled_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether to automatically try alternative resolutions. </p>

</div>
</div>
<a id="adb2698a4d9441132c4f9ba23a4dc4678" name="adb2698a4d9441132c4f9ba23a4dc4678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2698a4d9441132c4f9ba23a4dc4678">&#9670;&#160;</a></span>base_clock_hz_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> EspPwm::base_clock_hz_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Base clock frequency. </p>

</div>
</div>
<a id="ab3341c72b5f1d413999dfc44fd8d80d2" name="ab3341c72b5f1d413999dfc44fd8d80d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3341c72b5f1d413999dfc44fd8d80d2">&#9670;&#160;</a></span>channels_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="structEspPwm_1_1ChannelState.html">ChannelState</a>, <a class="el" href="#a1595caab94f2f77924d128115eab0be2">MAX_CHANNELS</a>&gt; EspPwm::channels_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Channel states. </p>

</div>
</div>
<a id="ac4da347398a044e97ecfd586a65d4470" name="ac4da347398a044e97ecfd586a65d4470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4da347398a044e97ecfd586a65d4470">&#9670;&#160;</a></span>clock_source_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="EspTypes__PWM_8h.html#ad387f5c3904a1913133dc217dacf7a82">hf_pwm_clock_source_t</a> EspPwm::clock_source_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current clock source. </p>

</div>
</div>
<a id="afdfcaf9396528e32f648a403fd4fb075" name="afdfcaf9396528e32f648a403fd4fb075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfcaf9396528e32f648a403fd4fb075">&#9670;&#160;</a></span>complementary_pairs_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="structEspPwm_1_1ComplementaryPair.html">ComplementaryPair</a>, <a class="el" href="#a1595caab94f2f77924d128115eab0be2">MAX_CHANNELS</a> / 2&gt; EspPwm::complementary_pairs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Complementary pairs. </p>

</div>
</div>
<a id="a364fe8d01eaea5c9664f43c8c2bd2dcb" name="a364fe8d01eaea5c9664f43c8c2bd2dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364fe8d01eaea5c9664f43c8c2bd2dcb">&#9670;&#160;</a></span>current_mode_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="EspTypes__PWM_8h.html#aa74b1b34478ef0fde22cd029366ab3fa">hf_pwm_mode_t</a> EspPwm::current_mode_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current operating mode. </p>

</div>
</div>
<a id="a825cbef48b32048590def430ae108584" name="a825cbef48b32048590def430ae108584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825cbef48b32048590def430ae108584">&#9670;&#160;</a></span>diagnostics_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhf__pwm__diagnostics__t.html">hf_pwm_diagnostics_t</a> EspPwm::diagnostics_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PWM diagnostics. </p>

</div>
</div>
<a id="ac60137ac8d1bee195299fd6b2fa88431" name="ac60137ac8d1bee195299fd6b2fa88431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60137ac8d1bee195299fd6b2fa88431">&#9670;&#160;</a></span>eviction_callback_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="EspTypes__PWM_8h.html#aa88988c1a4ef6005d3f20421ecba42ed">hf_pwm_eviction_callback_t</a> EspPwm::eviction_callback_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User callback for eviction consent. </p>

</div>
</div>
<a id="a2ae786082f476290ff5907881989d986" name="a2ae786082f476290ff5907881989d986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae786082f476290ff5907881989d986">&#9670;&#160;</a></span>eviction_callback_user_data_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* EspPwm::eviction_callback_user_data_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User data for eviction callback. </p>

</div>
</div>
<a id="a1f1584998723762eec8692090592650f" name="a1f1584998723762eec8692090592650f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1584998723762eec8692090592650f">&#9670;&#160;</a></span>eviction_policy_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="EspTypes__PWM_8h.html#ac87a4c9f233c95c6036c956aa21fdf72">hf_pwm_eviction_policy_t</a> EspPwm::eviction_policy_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timer eviction policy (default: STRICT_NO_EVICTION) </p>

</div>
</div>
<a id="ab200d2d51794d3c3f6c18945132bc7e4" name="ab200d2d51794d3c3f6c18945132bc7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab200d2d51794d3c3f6c18945132bc7e4">&#9670;&#160;</a></span>fade_functionality_installed_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EspPwm::fade_functionality_installed_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>LEDC fade functionality installed. </p>

</div>
</div>
<a id="a62f5455c00a2bf6bee32c4edeb5b90d0" name="a62f5455c00a2bf6bee32c4edeb5b90d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f5455c00a2bf6bee32c4edeb5b90d0">&#9670;&#160;</a></span>initialized_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; EspPwm::initialized_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialization state (atomic for lazy init) </p>

</div>
</div>
<a id="ad1b06777e74eedca37e5023ec23fc4ce" name="ad1b06777e74eedca37e5023ec23fc4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b06777e74eedca37e5023ec23fc4ce">&#9670;&#160;</a></span>last_global_error_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="BasePwm_8h.html#aba623d248c49dd773e0866ea7c6d7ac9">hf_pwm_err_t</a> EspPwm::last_global_error_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Last global error. </p>

</div>
</div>
<a id="a1595caab94f2f77924d128115eab0be2" name="a1595caab94f2f77924d128115eab0be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1595caab94f2f77924d128115eab0be2">&#9670;&#160;</a></span>MAX_CHANNELS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> EspPwm::MAX_CHANNELS = <a class="el" href="EspTypes__PWM_8h.html#a86d24d14ec124f4012f812f9853993f0">HF_PWM_MAX_CHANNELS</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum PWM channels. </p>

</div>
</div>
<a id="a9028b609b50b17802ce3b8da3ec39899" name="a9028b609b50b17802ce3b8da3ec39899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9028b609b50b17802ce3b8da3ec39899">&#9670;&#160;</a></span>MAX_FREQUENCY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> EspPwm::MAX_FREQUENCY = <a class="el" href="EspTypes__PWM_8h.html#aefdd9851ea138af7ce3b87a861c9f8b7">HF_PWM_MAX_FREQUENCY</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum frequency (Hz) </p>

</div>
</div>
<a id="a5ebf53a209f25236bafcb52fe0564d2a" name="a5ebf53a209f25236bafcb52fe0564d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebf53a209f25236bafcb52fe0564d2a">&#9670;&#160;</a></span>MAX_RESOLUTION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> EspPwm::MAX_RESOLUTION = <a class="el" href="EspTypes__PWM_8h.html#ae635150b452b279b29b65f799961d51f">HF_PWM_MAX_RESOLUTION</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum resolution bits. </p>

</div>
</div>
<a id="a625133f35c2449a53e048f63df138a89" name="a625133f35c2449a53e048f63df138a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625133f35c2449a53e048f63df138a89">&#9670;&#160;</a></span>MAX_TIMERS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="HardwareTypes_8h.html#a3aa2692c73b4cca0adc7139bd18ff613">hf_u8_t</a> EspPwm::MAX_TIMERS = <a class="el" href="EspTypes__PWM_8h.html#a188b45a8dc354e4753a2d2a3ade6b06e">HF_PWM_MAX_TIMERS</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum timer groups. </p>

</div>
</div>
<a id="af03e7350d2c885bbca5358ee3a183d10" name="af03e7350d2c885bbca5358ee3a183d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03e7350d2c885bbca5358ee3a183d10">&#9670;&#160;</a></span>MIN_FREQUENCY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="HardwareTypes_8h.html#a0a9e8f52f8fc4d5b4c197dd3923c50fd">hf_u32_t</a> EspPwm::MIN_FREQUENCY = <a class="el" href="EspTypes__PWM_8h.html#ab59b928c49e8f4ef0dbc7c1bac390c93">HF_PWM_MIN_FREQUENCY</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum frequency (Hz) </p>

</div>
</div>
<a id="ae4c8b8e2abef78e240fc60451b6d793e" name="ae4c8b8e2abef78e240fc60451b6d793e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c8b8e2abef78e240fc60451b6d793e">&#9670;&#160;</a></span>mutex_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRtosMutex.html">RtosMutex</a> EspPwm::mutex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread safety mutex. </p>

</div>
</div>
<a id="aefe4a2dfe1bccd062a299b1febb8aef8" name="aefe4a2dfe1bccd062a299b1febb8aef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe4a2dfe1bccd062a299b1febb8aef8">&#9670;&#160;</a></span>statistics_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhf__pwm__statistics__t.html">hf_pwm_statistics_t</a> EspPwm::statistics_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PWM statistics. </p>

</div>
</div>
<a id="ad569f2cfbea460323ab5847717019d75" name="ad569f2cfbea460323ab5847717019d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad569f2cfbea460323ab5847717019d75">&#9670;&#160;</a></span>timers_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="structEspPwm_1_1TimerState.html">TimerState</a>, <a class="el" href="#a625133f35c2449a53e048f63df138a89">MAX_TIMERS</a>&gt; EspPwm::timers_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Timer states. </p>

</div>
</div>
<a id="ac2592dd4dbe1e99213a7d1d4c69e67fd" name="ac2592dd4dbe1e99213a7d1d4c69e67fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2592dd4dbe1e99213a7d1d4c69e67fd">&#9670;&#160;</a></span>unit_config_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhf__pwm__unit__config__t.html">hf_pwm_unit_config_t</a> EspPwm::unit_config_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit configuration. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>inc/mcu/esp32/<a class="el" href="EspPwm_8h_source.html">EspPwm.h</a></li>
<li>src/mcu/esp32/<a class="el" href="EspPwm_8cpp.html">EspPwm.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classEspPwm.html">EspPwm</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
